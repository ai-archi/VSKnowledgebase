{"version":3,"file":"app.js","mappings":"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AY,OAAO,UAAU,KAAK,UAAU,UAAU,YAAY,OAAO,YAAY,MAAM,UAAU,YAAY,WAAW,YAAY,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,KAAK,YAAY,WAAW,UAAU,YAAY,OAAO,KAAK,UAAU,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,UAAU,MAAM,KAAK,YAAY,OAAO,KAAK,UAAU,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,YAAY,OAAO,KAAK,UAAU,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,YAAY,WAAW,MAAM,KAAK,UAAU,YAAY,WAAW,MAAM,KAAK,UAAU,UAAU,OAAO,QAAQ,UAAU,YAAY,aAAa,WAAW,OAAO,KAAK,UAAU,UAAU,OAAO,OAAO,UAAU,YAAY,OAAO,KAAK,UAAU,YAAY,WAAW,MAAM,KAAK,UAAU,UAAU,MAAM,KAAK,YAAY,WAAW,YAAY,aAAa,aAAa,WAAW,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,YAAY,aAAa,WAAW,YAAY,aAAa,aAAa,WAAW,UAAU,MAAM,KAAK,YAAY,OAAO,YAAY,MAAM,UAAU,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,UAAU,YAAY,OAAO,KAAK,UAAU,UAAU,UAAU,OAAO,KAAK,UAAU,MAAM,KAAK,YAAY,OAAO,KAAK,UAAU,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU,UAAU,UAAU,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,YAAY,OAAO,KAAK,UAAU,UAAU,YAAY,aAAa,OAAO,YAAY,MAAM,UAAU,YAAY,WAAW,YAAY,aAAa,OAAO,KAAK,UAAU,UAAU,YAAY,OAAO,KAAK,UAAU,UAAU,UAAU,UAAU,YAAY,WAAW,YAAY,aAAa,WAAW,OAAO,KAAK,UAAU,MAAM,KAAK,YAAY,aAAa,WAAW,YAAY,aAAa,WAAW,YAAY,OAAO,KAAK,YAAY,aAAa,WAAW,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,OAAO,KAAK,UAAU,UAAU,OAAO,YAAY,MAAM,YAAY,aA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;AAEA;AACA,KAAK;AACL,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;ACjEa;;AAEb,kCAAkC;;AAElC,8BAA8B;;AAE9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;;AAE7S,uCAAuC,uDAAuD,uCAAuC,SAAS,OAAO,oBAAoB;;AAEzK,yCAAyC,8FAA8F,wBAAwB,eAAe,eAAe,gBAAgB,YAAY,MAAM,wBAAwB,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,mDAAmD,UAAU,sBAAsB;;AAEve,gCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,E;;;;;;;;;;ACnCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAwC,GAAG,sBAAiB,GAAG,CAAI;;AAEnF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,qEAAqE,qBAAqB,cAAc;;AAExG;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,yDAAyD;AACzD,IAAI;;AAEJ;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;;;;;;;AC5QqJ;AACrJ,YAAkJ;;AAElJ;;AAEA;AACA;;AAEA,aAAa,+JAAG,CAAC,0IAAO;;;;AAIxB,iEAAe,0IAAO,aAAa,E;;;;;;;;;;;;;;;;ACZnC;;AAyBoB;;AAYA;;AAE6B;;AAEjD;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;;AAEA;AACA;AACA,aAAa,UAAU,iEAA0B;AACjD;;AAEA,mBAAmB,mDAAQ;AAC3B;AACA,aAAa,+BAA+B,iEAA0B;AACtE;;AAEA;AACA;AACA,aAAa,+BAA+B,iEAA0B;AACtE;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS,mDAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW,OAAO,yDAAkB,UAAU,0DAAmB;AACjE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,qIAAqI;AAC7I,QAAQ,wIAAwI;AAChJ,QAAQ,uIAAuI;AAC/I,QAAQ,0IAA0I;AAClJ,QAAQ,sJAAsJ;AAC9J;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,QAAQ,gIAAgI;AACxI,QAAQ,yIAAyI;AACjJ,QAAQ,sIAAsI;AAC9I,QAAQ,+IAA+I;AACvJ,QAAQ,sJAAsJ;AAC9J;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,oBAAoB;AACpB;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;AACrD;AACA,yDAAyD;AACzD,yDAAyD;AACzD,mEAAmE;AACnE,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,yDAAkB;AACnG,qFAAqF,0DAAmB;AACxG,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAkB;AACpD,oCAAoC,0DAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAkB;AAChC,aAAa,yDAAkB;AAC/B,cAAc,0DAAmB;AACjC,aAAa,0DAAmB;AAChC;AACA;AACA,wCAAwC,yDAAkB,IAAI,oDAAa;AAC3E,yCAAyC,0DAAmB,IAAI,oDAAa;AAC7E,oBAAoB,oDAAa;AACjC,oBAAoB,oDAAa;AACjC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA,0CAA0C,wBAAwB;AAClE,aAAa,sBAAsB,IAAI,kBAAkB;AACzD;AACA;AACA,gBAAgB,sBAAsB,uBAAuB,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB,EAAE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2DAA2D;AAC3D,sCAAsC,oDAAoD;AAC1F;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAsB;AACpD,8BAA8B,6DAAsB;AACpD,gCAAgC,oDAAa;AAC7C;AACA,kCAAkC,sDAAe;AACjD;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,6CAA6C,IAAI,GAAG,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAmB;AAC1C,sBAAsB,0DAAe;AACrC;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc,IAAI,cAAc;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+DAAwB;AACpD,4BAA4B,+DAAwB;AACpD,8BAA8B,4DAAqB;AACnD,sCAAsC,oEAA6B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAoB;AACvD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wDAAwD,6DAAsB;AAC9E;AACA;AACA;AACA,sDAAsD,6DAAsB;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAkB;AACtD,sCAAsC,0DAAmB;AACzD;AACA;AACA;AACA;AACA,6CAA6C,SAAS,IAAI,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAmB;AAC3C;AACA,4CAA4C,0DAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,GAAG,WAAW,IAAI,GAAG,GAAG,IAAI,QAAQ,UAAU,GAAG,WAAW,IAAI,UAAU,GAAG,cAAc,IAAI,GAAG,GAAG,IAAI,QAAQ,WAAW,GAAG,cAAc;AACtL,6BAA6B,WAAW,GAAG,WAAW,IAAI,GAAG,GAAG,IAAI,QAAQ,UAAU,GAAG,UAAU;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAiB;AACzD;AACA;AACA;AACA;AACA,iBAAiB,wDAAiB,mBAAmB,4DAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,gCAAgC,4DAAqB;AACrD;AACA,4EAA4E,4DAAqB;AACjG;AACA;AACA;AACA,iDAAiD,4DAAqB;AACtE;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,wBAAwB,4DAAqB;AAC7C;AACA;AACA;AACA,iDAAiD,4DAAqB;AACtE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAmB;AAC1C;AACA,qCAAqC,wDAAiB,mBAAmB,4DAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAS;AAC9B,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB,SAAS,eAAe;AACnF;AACA;AACA,mBAAmB,oDAAS;AAC5B,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D,kCAAkC,yBAAyB;AAC3D;AACA,6FAA6F,WAAW;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D,kCAAkC,yBAAyB;AAC3D;AACA,+FAA+F,WAAW;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA,6BAA6B,kDAAO;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,sBAAsB,sBAAsB;AAC5C,yBAAyB,4DAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAe;AACvB;AACA;AACA;AACA;AACA,uDAAuD,qDAAU,uBAAuB,gDAAS;AACjG,uDAAuD,qDAAU,uBAAuB,gDAAS;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,+BAA+B,kBAAkB,UAAU,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAe;AACvB;AACA;AACA;AACA;AACA,uDAAuD,qDAAU,uBAAuB,gDAAS;AACjG,uDAAuD,qDAAU,uBAAuB,gDAAS;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAAO;AAC3C,oCAAoC,8CAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAO,gBAAgB,8CAAO;AACxE;AACA;AACA;AACA,MAAM;AACN;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAO,mBAAmB,8CAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG,qDAAU,SAAS,gDAAS,MAAM,qDAAU,SAAS,gDAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC51DA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACA;AACA;;AAEA;AACP,IAAI,6BAA6B;AACjC,IAAI,8BAA8B;AAClC;;AAEO;AACP,IAAI,+BAA+B;AACnC,IAAI,gCAAgC;AACpC,IAAI,4BAA4B;AAChC,IAAI,2BAA2B;AAC/B;;AAEO,kCAAkC,EAAE;AACpC;AACA;AACA;;AAEP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEP;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB,EAAE,iBAAiB;AACxD;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,aAAa;;AAEvB;AACA;AACA,wEAAwE;AACxE;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP,WAAW;AACX;;AAEO;AACP;AACA;;AAEO;AACP;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP,YAAY,OAAO,EAAE,oCAAoC;AACzD;;AAEO;AACP,mCAAmC,aAAa,GAAG,aAAa;AAChE;;;;;;;;;;;;;;;;;;;;;;;;;ACjRA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,WAAW,GAAG,mBAAmB;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACmC;;;;;;;;UCrKnC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;WCNA,mC;;;;;;;;;;;;;;;;;ACAA;;AAEsB;AACgC;AACE;AAM3B;AAQJ;AAQA;;AAEzB;AACA;AACA;AACA,4BAA4B,8DAAY;AACxC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D,4BAA4B,+DAAY;AACxC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,mCAAmC,2BAA2B;AAC9D,YAAY,8DAAW;AACvB,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sCAAsC;AAC5F,MAAM;AACN,qDAAqD,yBAAyB,kBAAkB,GAAG,gBAAgB,EAAE;AACrH,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,8DAAmB;AACxG;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,yFAAyF,6DAAkB;AAC3G;AACA,KAAK;AACL;AACA;AACA;AACA,mFAAmF,4DAAiB;AACpG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB,UAAU,GAAG,QAAQ,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,6DAAkB;AACnG;AACA,KAAK;AACL;AACA;AACA;AACA,oEAAoE,6DAAkB;AACtF;AACA,KAAK;AACL;AACA;AACA;AACA,sEAAsE,kEAAuB;AAC7F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAY;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB,GAAG,kBAAkB,UAAU,iEAAkB,qBAAqB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAkB;AAC7C;AACA;AACA,yBAAyB,iEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,+BAA+B,iEAAkB;AACjD;AACA;AACA;AACA,2BAA2B,+DAAgB;AAC3C,wBAAwB,+DAAgB;AACxC;AACA;AACA;AACA,+BAA+B,iEAAkB;AACjD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,uCAAuC,sBAAsB;AAC7D,+BAA+B,iEAAkB;AACjD,UAAU;AACV,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,iEAAkB;AACjD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,oBAAoB;AACpD,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,sBAAsB;AACtD,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,oBAAoB;AACpD,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,yBAAyB;AACzD,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,yBAAyB;AACzD,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA,oBAAoB,YAAY,qBAAqB;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,YAAY,eAAe;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,YAAY,gBAAgB;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mCAAmC,sBAAsB;AACzD,MAAM;AACN,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAmD;AACtF;AACA;AACA;AACA;AACA,kCAAkC,qEAAsB,OAAO,+DAAoB;AACnF;AACA;AACA;AACA,oCAAoC,6DAAc,6BAA6B,qBAAqB,6DAAc,2BAA2B,oBAAoB,6DAAc,CAAC,+DAAoB,GAAG;AACvM;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe,SAAS,qBAAqB;AACzE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mCAAmC,sBAAsB;AACzD,eAAe,eAAe,0BAA0B,6DAAc,CAAC,+DAAoB,EAAE;AAC7F,MAAM;AACN,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mCAAmC,sBAAsB;AACzD,MAAM;AACN,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN,6BAA6B,YAAY;AACzC,MAAM;AACN,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,4DAA4D,kBAAkB;AAC9E;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,MAAM;AACN,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA","sources":["webpack://mermaid-editor/./app/styles.css","webpack://mermaid-editor/../../node_modules/.pnpm/css-loader@5.2.7_webpack@5.103.0/node_modules/css-loader/dist/runtime/api.js","webpack://mermaid-editor/../../node_modules/.pnpm/css-loader@5.2.7_webpack@5.103.0/node_modules/css-loader/dist/runtime/cssWithMappingToString.js","webpack://mermaid-editor/../../node_modules/.pnpm/style-loader@2.0.0_webpack@5.103.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://mermaid-editor/./app/styles.css?ba4c","webpack://mermaid-editor/./lib/DiagramCanvas.js","webpack://mermaid-editor/./lib/StateManager.js","webpack://mermaid-editor/./lib/types.js","webpack://mermaid-editor/./lib/utils.js","webpack://mermaid-editor/./lib/vscodeApi.js","webpack://mermaid-editor/webpack/bootstrap","webpack://mermaid-editor/webpack/runtime/compat get default export","webpack://mermaid-editor/webpack/runtime/define property getters","webpack://mermaid-editor/webpack/runtime/hasOwnProperty shorthand","webpack://mermaid-editor/webpack/runtime/make namespace object","webpack://mermaid-editor/webpack/runtime/nonce","webpack://mermaid-editor/./app/app.js"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/.pnpm/css-loader@5.2.7_webpack@5.103.0/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/.pnpm/css-loader@5.2.7_webpack@5.103.0/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Base styles */\\n* {\\n  box-sizing: border-box;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nhtml, body {\\n  height: 100%;\\n  overflow: hidden;\\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\\n  font-size: 14px;\\n}\\n\\n.app {\\n  display: flex;\\n  flex-direction: column;\\n  height: 100vh;\\n  background: #ffffff;\\n}\\n\\n/* Toolbar */\\n.toolbar {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 8px 16px;\\n  background: #f8f9fa;\\n  border-bottom: 1px solid #e9ecef;\\n  min-height: 40px;\\n}\\n\\n.status {\\n  font-size: 13px;\\n  color: #6c757d;\\n}\\n\\n.actions {\\n  display: flex;\\n  gap: 8px;\\n}\\n\\n.actions button {\\n  padding: 4px 12px;\\n  font-size: 13px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n}\\n\\n.actions button:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n.actions button:disabled {\\n  opacity: 0.5;\\n  cursor: not-allowed;\\n}\\n\\n/* Workspace */\\n.workspace {\\n  display: flex;\\n  flex: 1;\\n  overflow: hidden;\\n}\\n\\n/* Style Panel */\\n.style-panel {\\n  width: 280px;\\n  border-right: 1px solid #e9ecef;\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n  overflow-y: auto;\\n}\\n\\n.panel-header {\\n  padding: 12px 16px;\\n  border-bottom: 1px solid #e9ecef;\\n  background: #f8f9fa;\\n}\\n\\n.panel-title {\\n  font-weight: 600;\\n  font-size: 14px;\\n  display: block;\\n  margin-bottom: 4px;\\n}\\n\\n.panel-caption {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n\\n.panel-caption.muted {\\n  color: #adb5bd;\\n}\\n\\n.panel-body {\\n  padding: 16px;\\n  flex: 1;\\n}\\n\\n.style-section {\\n  margin-bottom: 24px;\\n}\\n\\n.section-heading {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  margin-bottom: 12px;\\n}\\n\\n.section-heading h3 {\\n  font-size: 14px;\\n  font-weight: 600;\\n}\\n\\n.section-caption {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n\\n.section-caption.muted {\\n  color: #adb5bd;\\n}\\n\\n.style-controls {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 12px;\\n}\\n\\n.style-control {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 4px;\\n}\\n\\n.style-control span {\\n  font-size: 12px;\\n  color: #495057;\\n}\\n\\n.style-control input[type=\\\"color\\\"],\\n.style-control input[type=\\\"text\\\"],\\n.style-control input[type=\\\"number\\\"],\\n.style-control select {\\n  padding: 6px;\\n  border: 1px solid #dee2e6;\\n  border-radius: 4px;\\n  font-size: 13px;\\n}\\n\\n.style-control input[type=\\\"color\\\"] {\\n  height: 36px;\\n  cursor: pointer;\\n}\\n\\n.style-control:disabled,\\n.style-control[aria-disabled=\\\"true\\\"] input,\\n.style-control[aria-disabled=\\\"true\\\"] select {\\n  opacity: 0.5;\\n  cursor: not-allowed;\\n}\\n\\n.image-control {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.image-control-actions {\\n  display: flex;\\n  gap: 8px;\\n}\\n\\n.image-control-actions button {\\n  padding: 6px 12px;\\n  font-size: 12px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n}\\n\\n.image-control-actions button:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n.image-control-meta {\\n  font-size: 11px;\\n  color: #6c757d;\\n}\\n\\n.image-control-meta.muted {\\n  color: #adb5bd;\\n}\\n\\n.style-reset {\\n  margin-top: 12px;\\n  padding: 6px 12px;\\n  font-size: 12px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n  width: 100%;\\n}\\n\\n.style-reset:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n/* Diagram Container */\\n.diagram-container {\\n  flex: 1;\\n  position: relative;\\n  overflow: hidden;\\n  background: #ffffff;\\n}\\n\\n.diagram-wrapper {\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n}\\n\\n.diagram {\\n  width: 100%;\\n  height: 100%;\\n  cursor: default;\\n}\\n\\n.diagram .node {\\n  cursor: move;\\n}\\n\\n.diagram .node.selected {\\n  filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.5));\\n}\\n\\n.diagram .edge {\\n  cursor: pointer;\\n}\\n\\n.diagram .edge.selected {\\n  filter: drop-shadow(0 0 2px rgba(59, 130, 246, 0.5));\\n}\\n\\n.diagram .handle {\\n  fill: #3b82f6;\\n  stroke: #ffffff;\\n  stroke-width: 2;\\n  cursor: move;\\n}\\n\\n.diagram .handle.active {\\n  fill: #10b981;\\n}\\n\\n.diagram .handle:hover {\\n  fill: #2563eb;\\n}\\n\\n.diagram .subgraph {\\n  cursor: grab;\\n}\\n\\n.diagram .subgraph:active {\\n  cursor: grabbing;\\n}\\n\\n.diagram .alignment-guide {\\n  stroke: #3b82f6;\\n  stroke-width: 1;\\n  stroke-dasharray: 4 4;\\n  pointer-events: none;\\n}\\n\\n/* Source Panel */\\n.source-panel {\\n  width: 320px;\\n  border-left: 1px solid #e9ecef;\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n}\\n\\n.panel-path {\\n  font-size: 11px;\\n  color: #6c757d;\\n  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\\n}\\n\\n.source-editor {\\n  flex: 1;\\n  padding: 12px;\\n  border: none;\\n  resize: none;\\n  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\\n  font-size: 13px;\\n  line-height: 1.5;\\n  background: #ffffff;\\n  color: #212529;\\n}\\n\\n.source-editor:focus {\\n  outline: none;\\n}\\n\\n.panel-footer {\\n  padding: 8px 12px;\\n  border-top: 1px solid #e9ecef;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  font-size: 11px;\\n  background: #f8f9fa;\\n}\\n\\n.source-status {\\n  padding: 2px 6px;\\n  border-radius: 3px;\\n  font-size: 11px;\\n}\\n\\n.source-status.synced {\\n  color: #10b981;\\n}\\n\\n.source-status.pending {\\n  color: #f59e0b;\\n}\\n\\n.source-status.saving {\\n  color: #3b82f6;\\n}\\n\\n.source-status.error {\\n  color: #ef4444;\\n}\\n\\n.selection-label {\\n  color: #6c757d;\\n  font-size: 11px;\\n}\\n\\n/* Error Message */\\n.error {\\n  padding: 8px 16px;\\n  background: #fee2e2;\\n  color: #991b1b;\\n  border-top: 1px solid #fecaca;\\n  font-size: 13px;\\n}\\n\\n/* Placeholder */\\n.placeholder {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  height: 100%;\\n  color: #6c757d;\\n  font-size: 14px;\\n}\\n\\n/* Context Menu */\\n.context-menu {\\n  position: absolute;\\n  background: #ffffff;\\n  border: 1px solid #dee2e6;\\n  border-radius: 4px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\\n  padding: 4px 0;\\n  z-index: 1000;\\n  min-width: 120px;\\n}\\n\\n.context-menu button {\\n  width: 100%;\\n  padding: 8px 16px;\\n  text-align: left;\\n  border: none;\\n  background: none;\\n  cursor: pointer;\\n  font-size: 13px;\\n  color: #212529;\\n}\\n\\n.context-menu button:hover {\\n  background: #f8f9fa;\\n}\\n\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./app/styles.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/* Base styles */\\n* {\\n  box-sizing: border-box;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nhtml, body {\\n  height: 100%;\\n  overflow: hidden;\\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\\n  font-size: 14px;\\n}\\n\\n.app {\\n  display: flex;\\n  flex-direction: column;\\n  height: 100vh;\\n  background: #ffffff;\\n}\\n\\n/* Toolbar */\\n.toolbar {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 8px 16px;\\n  background: #f8f9fa;\\n  border-bottom: 1px solid #e9ecef;\\n  min-height: 40px;\\n}\\n\\n.status {\\n  font-size: 13px;\\n  color: #6c757d;\\n}\\n\\n.actions {\\n  display: flex;\\n  gap: 8px;\\n}\\n\\n.actions button {\\n  padding: 4px 12px;\\n  font-size: 13px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n}\\n\\n.actions button:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n.actions button:disabled {\\n  opacity: 0.5;\\n  cursor: not-allowed;\\n}\\n\\n/* Workspace */\\n.workspace {\\n  display: flex;\\n  flex: 1;\\n  overflow: hidden;\\n}\\n\\n/* Style Panel */\\n.style-panel {\\n  width: 280px;\\n  border-right: 1px solid #e9ecef;\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n  overflow-y: auto;\\n}\\n\\n.panel-header {\\n  padding: 12px 16px;\\n  border-bottom: 1px solid #e9ecef;\\n  background: #f8f9fa;\\n}\\n\\n.panel-title {\\n  font-weight: 600;\\n  font-size: 14px;\\n  display: block;\\n  margin-bottom: 4px;\\n}\\n\\n.panel-caption {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n\\n.panel-caption.muted {\\n  color: #adb5bd;\\n}\\n\\n.panel-body {\\n  padding: 16px;\\n  flex: 1;\\n}\\n\\n.style-section {\\n  margin-bottom: 24px;\\n}\\n\\n.section-heading {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  margin-bottom: 12px;\\n}\\n\\n.section-heading h3 {\\n  font-size: 14px;\\n  font-weight: 600;\\n}\\n\\n.section-caption {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n\\n.section-caption.muted {\\n  color: #adb5bd;\\n}\\n\\n.style-controls {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 12px;\\n}\\n\\n.style-control {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 4px;\\n}\\n\\n.style-control span {\\n  font-size: 12px;\\n  color: #495057;\\n}\\n\\n.style-control input[type=\\\"color\\\"],\\n.style-control input[type=\\\"text\\\"],\\n.style-control input[type=\\\"number\\\"],\\n.style-control select {\\n  padding: 6px;\\n  border: 1px solid #dee2e6;\\n  border-radius: 4px;\\n  font-size: 13px;\\n}\\n\\n.style-control input[type=\\\"color\\\"] {\\n  height: 36px;\\n  cursor: pointer;\\n}\\n\\n.style-control:disabled,\\n.style-control[aria-disabled=\\\"true\\\"] input,\\n.style-control[aria-disabled=\\\"true\\\"] select {\\n  opacity: 0.5;\\n  cursor: not-allowed;\\n}\\n\\n.image-control {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.image-control-actions {\\n  display: flex;\\n  gap: 8px;\\n}\\n\\n.image-control-actions button {\\n  padding: 6px 12px;\\n  font-size: 12px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n}\\n\\n.image-control-actions button:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n.image-control-meta {\\n  font-size: 11px;\\n  color: #6c757d;\\n}\\n\\n.image-control-meta.muted {\\n  color: #adb5bd;\\n}\\n\\n.style-reset {\\n  margin-top: 12px;\\n  padding: 6px 12px;\\n  font-size: 12px;\\n  border: 1px solid #dee2e6;\\n  background: #ffffff;\\n  border-radius: 4px;\\n  cursor: pointer;\\n  width: 100%;\\n}\\n\\n.style-reset:hover:not(:disabled) {\\n  background: #e9ecef;\\n}\\n\\n/* Diagram Container */\\n.diagram-container {\\n  flex: 1;\\n  position: relative;\\n  overflow: hidden;\\n  background: #ffffff;\\n}\\n\\n.diagram-wrapper {\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n}\\n\\n.diagram {\\n  width: 100%;\\n  height: 100%;\\n  cursor: default;\\n}\\n\\n.diagram .node {\\n  cursor: move;\\n}\\n\\n.diagram .node.selected {\\n  filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.5));\\n}\\n\\n.diagram .edge {\\n  cursor: pointer;\\n}\\n\\n.diagram .edge.selected {\\n  filter: drop-shadow(0 0 2px rgba(59, 130, 246, 0.5));\\n}\\n\\n.diagram .handle {\\n  fill: #3b82f6;\\n  stroke: #ffffff;\\n  stroke-width: 2;\\n  cursor: move;\\n}\\n\\n.diagram .handle.active {\\n  fill: #10b981;\\n}\\n\\n.diagram .handle:hover {\\n  fill: #2563eb;\\n}\\n\\n.diagram .subgraph {\\n  cursor: grab;\\n}\\n\\n.diagram .subgraph:active {\\n  cursor: grabbing;\\n}\\n\\n.diagram .alignment-guide {\\n  stroke: #3b82f6;\\n  stroke-width: 1;\\n  stroke-dasharray: 4 4;\\n  pointer-events: none;\\n}\\n\\n/* Source Panel */\\n.source-panel {\\n  width: 320px;\\n  border-left: 1px solid #e9ecef;\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n}\\n\\n.panel-path {\\n  font-size: 11px;\\n  color: #6c757d;\\n  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\\n}\\n\\n.source-editor {\\n  flex: 1;\\n  padding: 12px;\\n  border: none;\\n  resize: none;\\n  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\\n  font-size: 13px;\\n  line-height: 1.5;\\n  background: #ffffff;\\n  color: #212529;\\n}\\n\\n.source-editor:focus {\\n  outline: none;\\n}\\n\\n.panel-footer {\\n  padding: 8px 12px;\\n  border-top: 1px solid #e9ecef;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  font-size: 11px;\\n  background: #f8f9fa;\\n}\\n\\n.source-status {\\n  padding: 2px 6px;\\n  border-radius: 3px;\\n  font-size: 11px;\\n}\\n\\n.source-status.synced {\\n  color: #10b981;\\n}\\n\\n.source-status.pending {\\n  color: #f59e0b;\\n}\\n\\n.source-status.saving {\\n  color: #3b82f6;\\n}\\n\\n.source-status.error {\\n  color: #ef4444;\\n}\\n\\n.selection-label {\\n  color: #6c757d;\\n  font-size: 11px;\\n}\\n\\n/* Error Message */\\n.error {\\n  padding: 8px 16px;\\n  background: #fee2e2;\\n  color: #991b1b;\\n  border-top: 1px solid #fecaca;\\n  font-size: 13px;\\n}\\n\\n/* Placeholder */\\n.placeholder {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  height: 100%;\\n  color: #6c757d;\\n  font-size: 14px;\\n}\\n\\n/* Context Menu */\\n.context-menu {\\n  position: absolute;\\n  background: #ffffff;\\n  border: 1px solid #dee2e6;\\n  border-radius: 4px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\\n  padding: 4px 0;\\n  z-index: 1000;\\n  min-width: 120px;\\n}\\n\\n.context-menu button {\\n  width: 100%;\\n  padding: 8px 16px;\\n  text-align: left;\\n  border: none;\\n  background: none;\\n  cursor: pointer;\\n  font-size: 13px;\\n  color: #212529;\\n}\\n\\n.context-menu button:hover {\\n  background: #f8f9fa;\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","\"use strict\";\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce = typeof __webpack_nonce__ !== 'undefined' ? __webpack_nonce__ : null;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","import api from \"!../../../node_modules/.pnpm/style-loader@2.0.0_webpack@5.103.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../node_modules/.pnpm/css-loader@5.2.7_webpack@5.103.0/node_modules/css-loader/dist/cjs.js!./styles.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","// DiagramCanvas - Core rendering and interaction (converted from React component)\n\nimport {\n  DEFAULT_NODE_WIDTH,\n  DEFAULT_NODE_HEIGHT,\n  NODE_LABEL_HEIGHT,\n  NODE_TEXT_LINE_HEIGHT,\n  LAYOUT_MARGIN,\n  HANDLE_RADIUS,\n  EPSILON,\n  GRID_SIZE,\n  ALIGN_THRESHOLD,\n  DEFAULT_NODE_STROKE,\n  DEFAULT_NODE_TEXT,\n  DEFAULT_EDGE_COLOR,\n  SUBGRAPH_FILL,\n  SUBGRAPH_STROKE,\n  SUBGRAPH_LABEL_COLOR,\n  SUBGRAPH_BORDER_RADIUS,\n  EDGE_LABEL_FONT_SIZE,\n  EDGE_LABEL_LINE_HEIGHT,\n  EDGE_LABEL_BACKGROUND,\n  EDGE_LABEL_BACKGROUND_OPACITY,\n  EDGE_LABEL_BORDER_RADIUS,\n  EDGE_LABEL_VERTICAL_OFFSET,\n} from './types.js';\n\nimport {\n  midpoint,\n  isClose,\n  centroid,\n  distanceToSegment,\n  normalizeLabelLines,\n  measureLabelBox,\n  snapToGrid,\n  svgSafeId,\n  polygonPoints,\n} from './utils.js';\n\nimport { DEFAULT_NODE_COLORS } from './types.js';\n\n// Helper functions\nfunction interiorPoints(route) {\n  if (route.length <= 2) {\n    return [];\n  }\n  return route.slice(1, route.length - 1).map(point => ({ ...point }));\n}\n\nfunction labelCenterForRoute(route) {\n  if (route.length === 0) {\n    return { x: 0, y: -EDGE_LABEL_VERTICAL_OFFSET };\n  }\n\n  const fallback = centroid(route);\n  if (route.length <= 2) {\n    return { x: fallback.x, y: fallback.y - EDGE_LABEL_VERTICAL_OFFSET };\n  }\n\n  const candidates = route.slice(1, route.length - 1);\n  if (candidates.length === 0) {\n    return { x: fallback.x, y: fallback.y - EDGE_LABEL_VERTICAL_OFFSET };\n  }\n\n  if (candidates.length === 1) {\n    return { ...candidates[0] };\n  }\n\n  let best = candidates[0];\n  let bestDistance = Number.POSITIVE_INFINITY;\n  for (const point of candidates) {\n    const distance = Math.hypot(point.x - fallback.x, point.y - fallback.y);\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      best = point;\n    }\n  }\n\n  return { ...best };\n}\n\nfunction defaultHandleForRoute(route, start, end) {\n  const interior = interiorPoints(route);\n  if (interior.length > 0) {\n    const index = Math.floor(interior.length / 2);\n    return { ...interior[index] };\n  }\n  return midpoint(start, end);\n}\n\nfunction createNodeBox(position, width, height) {\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n  return {\n    left: position.x - halfWidth,\n    right: position.x + halfWidth,\n    centerX: position.x,\n    top: position.y - halfHeight,\n    bottom: position.y + halfHeight,\n    centerY: position.y,\n  };\n}\n\nfunction resolveNodeDimensions(id, dimensions) {\n  const dims = dimensions.get(id);\n  if (dims) {\n    return dims;\n  }\n  if (id.startsWith('edge:')) {\n    return { width: 0, height: 0 };\n  }\n  return { width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT };\n}\n\nfunction computeNodeAlignment(nodeId, proposed, nodes, threshold, dimensions) {\n  const movingDimensions = resolveNodeDimensions(nodeId, dimensions);\n  const movingBox = createNodeBox(proposed, movingDimensions.width, movingDimensions.height);\n  let bestVertical = null;\n  let bestHorizontal = null;\n\n  for (const [otherId, point] of nodes) {\n    if (otherId === nodeId) {\n      continue;\n    }\n    const otherDimensions = resolveNodeDimensions(otherId, dimensions);\n    const otherBox = createNodeBox(point, otherDimensions.width, otherDimensions.height);\n\n    const verticalCandidates = [\n      { diff: otherBox.left - movingBox.left, value: () => proposed.x + (otherBox.left - movingBox.left), kind: 'edge', line: otherBox.left },\n      { diff: otherBox.right - movingBox.left, value: () => proposed.x + (otherBox.right - movingBox.left), kind: 'edge', line: otherBox.right },\n      { diff: otherBox.left - movingBox.right, value: () => proposed.x + (otherBox.left - movingBox.right), kind: 'edge', line: otherBox.left },\n      { diff: otherBox.right - movingBox.right, value: () => proposed.x + (otherBox.right - movingBox.right), kind: 'edge', line: otherBox.right },\n      { diff: otherBox.centerX - movingBox.centerX, value: () => proposed.x + (otherBox.centerX - movingBox.centerX), kind: 'center', line: otherBox.centerX },\n    ];\n\n    for (const candidate of verticalCandidates) {\n      const absDiff = Math.abs(candidate.diff);\n      if (absDiff > threshold) {\n        continue;\n      }\n      if (bestVertical && Math.abs(bestVertical.diff) <= absDiff) {\n        continue;\n      }\n      const alignedX = candidate.value();\n      const alignedBox = createNodeBox({ x: alignedX, y: proposed.y }, movingDimensions.width, movingDimensions.height);\n      bestVertical = {\n        diff: candidate.diff,\n        value: alignedX,\n        guide: {\n          axis: 'vertical',\n          x: candidate.kind === 'center' ? alignedBox.centerX : candidate.line,\n          y1: Math.min(alignedBox.top, otherBox.top),\n          y2: Math.max(alignedBox.bottom, otherBox.bottom),\n          kind: candidate.kind,\n          sourceId: nodeId,\n          targetId: otherId,\n        },\n      };\n    }\n\n    const horizontalCandidates = [\n      { diff: otherBox.top - movingBox.top, value: () => proposed.y + (otherBox.top - movingBox.top), kind: 'edge', line: otherBox.top },\n      { diff: otherBox.bottom - movingBox.top, value: () => proposed.y + (otherBox.bottom - movingBox.top), kind: 'edge', line: otherBox.bottom },\n      { diff: otherBox.top - movingBox.bottom, value: () => proposed.y + (otherBox.top - movingBox.bottom), kind: 'edge', line: otherBox.top },\n      { diff: otherBox.bottom - movingBox.bottom, value: () => proposed.y + (otherBox.bottom - movingBox.bottom), kind: 'edge', line: otherBox.bottom },\n      { diff: otherBox.centerY - movingBox.centerY, value: () => proposed.y + (otherBox.centerY - movingBox.centerY), kind: 'center', line: otherBox.centerY },\n    ];\n\n    for (const candidate of horizontalCandidates) {\n      const absDiff = Math.abs(candidate.diff);\n      if (absDiff > threshold) {\n        continue;\n      }\n      if (bestHorizontal && Math.abs(bestHorizontal.diff) <= absDiff) {\n        continue;\n      }\n      const alignedY = candidate.value();\n      const alignedBox = createNodeBox({ x: proposed.x, y: alignedY }, movingDimensions.width, movingDimensions.height);\n      bestHorizontal = {\n        diff: candidate.diff,\n        value: alignedY,\n        guide: {\n          axis: 'horizontal',\n          y: candidate.kind === 'center' ? alignedBox.centerY : candidate.line,\n          x1: Math.min(alignedBox.left, otherBox.left),\n          x2: Math.max(alignedBox.right, otherBox.right),\n          kind: candidate.kind,\n          sourceId: nodeId,\n          targetId: otherId,\n        },\n      };\n    }\n  }\n\n  const guides = {};\n  let appliedX = false;\n  let appliedY = false;\n\n  let finalX = proposed.x;\n  if (bestVertical) {\n    finalX = bestVertical.value;\n    guides.vertical = bestVertical.guide;\n    appliedX = true;\n  }\n\n  let finalY = proposed.y;\n  if (bestHorizontal) {\n    finalY = bestHorizontal.value;\n    guides.horizontal = bestHorizontal.guide;\n    appliedY = true;\n  }\n\n  const finalPosition = { x: finalX, y: finalY };\n  const finalBox = createNodeBox(finalPosition, movingDimensions.width, movingDimensions.height);\n\n  if (guides.vertical) {\n    const targetPoint = nodes.find(entry => entry[0] === guides.vertical.targetId)?.[1];\n    if (targetPoint) {\n      const targetDimensions = resolveNodeDimensions(guides.vertical.targetId, dimensions);\n      const targetBox = createNodeBox(targetPoint, targetDimensions.width, targetDimensions.height);\n      guides.vertical.x = guides.vertical.kind === 'center' ? finalBox.centerX : guides.vertical.x;\n      guides.vertical.y1 = Math.min(finalBox.top, targetBox.top);\n      guides.vertical.y2 = Math.max(finalBox.bottom, targetBox.bottom);\n    }\n  }\n\n  if (guides.horizontal) {\n    const targetPoint = nodes.find(entry => entry[0] === guides.horizontal.targetId)?.[1];\n    if (targetPoint) {\n      const targetDimensions = resolveNodeDimensions(guides.horizontal.targetId, dimensions);\n      const targetBox = createNodeBox(targetPoint, targetDimensions.width, targetDimensions.height);\n      guides.horizontal.y = guides.horizontal.kind === 'center' ? finalBox.centerY : guides.horizontal.y;\n      guides.horizontal.x1 = Math.min(finalBox.left, targetBox.left);\n      guides.horizontal.x2 = Math.max(finalBox.right, targetBox.right);\n    }\n  }\n\n  return {\n    position: finalPosition,\n    guides: (guides.vertical || guides.horizontal) ? guides : {},\n    appliedX,\n    appliedY,\n  };\n}\n\nfunction guidesEqual(a, b) {\n  if (!!a.vertical !== !!b.vertical) return false;\n  if (a.vertical && b.vertical) {\n    if (a.vertical.x !== b.vertical.x || a.vertical.y1 !== b.vertical.y1 || \n        a.vertical.y2 !== b.vertical.y2 || a.vertical.kind !== b.vertical.kind) {\n      return false;\n    }\n  }\n  if (!!a.horizontal !== !!b.horizontal) return false;\n  if (a.horizontal && b.horizontal) {\n    if (a.horizontal.y !== b.horizontal.y || a.horizontal.x1 !== b.horizontal.x1 || \n        a.horizontal.x2 !== b.horizontal.x2 || a.horizontal.kind !== b.horizontal.kind) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport class DiagramCanvas {\n  constructor(container, options = {}) {\n    this.container = container;\n    this.options = options;\n    \n    // State\n    this.diagram = null;\n    this.selectedNodeId = null;\n    this.selectedEdgeId = null;\n    this.dragState = null;\n    this.draftNodes = {};\n    this.draftEdges = {};\n    this.draftSubgraphs = {};\n    this.alignmentGuides = {};\n    this.contextMenu = { visible: false, x: 0, y: 0, target: null };\n    this.bounds = { width: 800, height: 600, offsetX: 0, offsetY: 0 };\n    this.nodeDimensions = new Map();\n    \n    // Callbacks\n    this.onNodeMove = options.onNodeMove || (() => {});\n    this.onEdgeMove = options.onEdgeMove || (() => {});\n    this.onLayoutUpdate = options.onLayoutUpdate || null;\n    this.onSelectNode = options.onSelectNode || (() => {});\n    this.onSelectEdge = options.onSelectEdge || (() => {});\n    this.onDragStateChange = options.onDragStateChange || (() => {});\n    this.onDeleteNode = options.onDeleteNode || (() => {});\n    this.onDeleteEdge = options.onDeleteEdge || (() => {});\n    \n    // DOM elements\n    this.wrapper = null;\n    this.svg = null;\n    \n    this.init();\n  }\n  \n  init() {\n    // Create wrapper\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = 'diagram-wrapper';\n    this.container.appendChild(this.wrapper);\n    \n    // Create SVG\n    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svg.setAttribute('class', 'diagram');\n    this.wrapper.appendChild(this.svg);\n    \n    // Setup event listeners\n    this.setupEventListeners();\n    \n    // Create arrow markers\n    this.createArrowMarkers();\n  }\n  \n  setupEventListeners() {\n    this.svg.addEventListener('pointerdown', (e) => this.handleCanvasPointerDown(e));\n    this.svg.addEventListener('pointermove', (e) => this.handlePointerMove(e));\n    this.svg.addEventListener('pointerup', (e) => this.handlePointerUp(e));\n    this.svg.addEventListener('pointercancel', (e) => this.handlePointerCancel(e));\n    this.svg.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.closeContextMenu();\n    });\n    \n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => this.handleKeyDown(e));\n  }\n  \n  createArrowMarkers() {\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    \n    // Arrow end marker\n    const markerEnd = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    markerEnd.setAttribute('id', 'arrow-end');\n    markerEnd.setAttribute('markerWidth', '12');\n    markerEnd.setAttribute('markerHeight', '12');\n    markerEnd.setAttribute('refX', '10');\n    markerEnd.setAttribute('refY', '6');\n    markerEnd.setAttribute('orient', 'auto');\n    markerEnd.setAttribute('markerUnits', 'strokeWidth');\n    const pathEnd = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    pathEnd.setAttribute('d', 'M2,2 L10,6 L2,10 z');\n    pathEnd.setAttribute('fill', 'context-stroke');\n    markerEnd.appendChild(pathEnd);\n    \n    // Arrow start marker\n    const markerStart = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    markerStart.setAttribute('id', 'arrow-start');\n    markerStart.setAttribute('markerWidth', '12');\n    markerStart.setAttribute('markerHeight', '12');\n    markerStart.setAttribute('refX', '2');\n    markerStart.setAttribute('refY', '6');\n    markerStart.setAttribute('orient', 'auto');\n    markerStart.setAttribute('markerUnits', 'strokeWidth');\n    const pathStart = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    pathStart.setAttribute('d', 'M10,2 L2,6 L10,10 z');\n    pathStart.setAttribute('fill', 'context-stroke');\n    markerStart.appendChild(pathStart);\n    \n    defs.appendChild(markerEnd);\n    defs.appendChild(markerStart);\n    this.svg.appendChild(defs);\n  }\n  \n  setDiagram(diagram) {\n    this.diagram = diagram;\n    \n    // Update node dimensions\n    this.nodeDimensions.clear();\n    for (const node of diagram.nodes) {\n      const width = Number.isFinite(node.width) && node.width > 0 ? node.width : DEFAULT_NODE_WIDTH;\n      const height = Number.isFinite(node.height) && node.height > 0 ? node.height : DEFAULT_NODE_HEIGHT;\n      this.nodeDimensions.set(node.id, { width, height });\n    }\n    \n    this.updateBounds();\n    this.render();\n  }\n  \n  setSelectedNode(id) {\n    this.selectedNodeId = id;\n    if (id) {\n      this.selectedEdgeId = null;\n    }\n    this.render();\n  }\n  \n  setSelectedEdge(id) {\n    this.selectedEdgeId = id;\n    if (id) {\n      this.selectedNodeId = null;\n    }\n    this.render();\n  }\n  \n  updateBounds() {\n    if (!this.diagram) {\n      return;\n    }\n    \n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    \n    const extend = (point, halfWidth = 0, halfHeight = 0) => {\n      minX = Math.min(minX, point.x - halfWidth);\n      maxX = Math.max(maxX, point.x + halfWidth);\n      minY = Math.min(minY, point.y - halfHeight);\n      maxY = Math.max(maxY, point.y + halfHeight);\n    };\n    \n    // Include nodes\n    for (const node of this.diagram.nodes) {\n      const position = this.draftNodes[node.id] ?? node.overridePosition ?? node.renderedPosition;\n      const width = node.width ?? DEFAULT_NODE_WIDTH;\n      const height = node.height ?? DEFAULT_NODE_HEIGHT;\n      extend(position, width / 2, height / 2);\n    }\n    \n    // Include edges\n    for (const edge of this.diagram.edges) {\n      const route = this.getEdgeRoute(edge);\n      for (const point of route) {\n        extend(point);\n      }\n    }\n    \n    if (!Number.isFinite(minX)) {\n      minX = -DEFAULT_NODE_WIDTH / 2;\n      maxX = DEFAULT_NODE_WIDTH / 2;\n      minY = -DEFAULT_NODE_HEIGHT / 2;\n      maxY = DEFAULT_NODE_HEIGHT / 2;\n    }\n    \n    const width = Math.max(maxX - minX, DEFAULT_NODE_WIDTH) + LAYOUT_MARGIN * 2;\n    const height = Math.max(maxY - minY, DEFAULT_NODE_HEIGHT) + LAYOUT_MARGIN * 2;\n    const offsetX = LAYOUT_MARGIN - minX;\n    const offsetY = LAYOUT_MARGIN - minY;\n    \n    this.bounds = { width, height, offsetX, offsetY };\n  }\n  \n  getEdgeRoute(edge) {\n    const from = this.getNodePosition(edge.from);\n    const to = this.getNodePosition(edge.to);\n    \n    if (!from || !to) {\n      return [];\n    }\n    \n    const draftOverride = this.draftEdges[edge.id];\n    const hasDraftOverride = draftOverride !== undefined;\n    const baseOverrides = draftOverride ?? edge.overridePoints ?? [];\n    const overridePoints = baseOverrides.map(point => ({ x: point.x, y: point.y }));\n    const hasOverride = overridePoints.length > 0;\n    \n    const renderedRoute = (edge.renderedPoints && edge.renderedPoints.length >= 2)\n      ? edge.renderedPoints.map(point => ({ x: point.x, y: point.y }))\n      : (edge.autoPoints && edge.autoPoints.length >= 2)\n        ? edge.autoPoints.map(point => ({ x: point.x, y: point.y }))\n        : [{ x: from.x, y: from.y }, { x: to.x, y: to.y }];\n    \n    if (hasDraftOverride) {\n      return [{ x: from.x, y: from.y }, ...overridePoints, { x: to.x, y: to.y }];\n    }\n    \n    return renderedRoute;\n  }\n  \n  getNodePosition(nodeId) {\n    const node = this.diagram.nodes.find(n => n.id === nodeId);\n    if (!node) {\n      return null;\n    }\n    return this.draftNodes[nodeId] ?? node.overridePosition ?? node.renderedPosition ?? node.autoPosition;\n  }\n  \n  toScreen(point) {\n    return {\n      x: point.x + this.bounds.offsetX,\n      y: point.y + this.bounds.offsetY,\n    };\n  }\n  \n  getDiagramPointFromClient(clientX, clientY) {\n    if (!this.svg) {\n      return null;\n    }\n    const point = this.svg.createSVGPoint();\n    point.x = clientX;\n    point.y = clientY;\n    const ctm = this.svg.getScreenCTM();\n    if (!ctm) {\n      return null;\n    }\n    const transformed = point.matrixTransform(ctm.inverse());\n    return {\n      x: transformed.x - this.bounds.offsetX,\n      y: transformed.y - this.bounds.offsetY,\n    };\n  }\n  \n  render() {\n    if (!this.diagram) {\n      return;\n    }\n    \n    this.updateBounds();\n    \n    // Update SVG viewBox\n    this.svg.setAttribute('viewBox', `0 0 ${this.bounds.width} ${this.bounds.height}`);\n    \n    // Clear existing content (except defs)\n    const defs = this.svg.querySelector('defs');\n    this.svg.innerHTML = '';\n    if (defs) {\n      this.svg.appendChild(defs);\n    }\n    \n    // Render subgraphs\n    this.renderSubgraphs();\n    \n    // Render edges\n    this.renderEdges();\n    \n    // Render nodes\n    this.renderNodes();\n    \n    // Render alignment guides\n    this.renderAlignmentGuides();\n  }\n  \n  renderSubgraphs() {\n    if (!this.diagram.subgraphs) {\n      return;\n    }\n    \n    const subgraphs = [...this.diagram.subgraphs].sort((a, b) => {\n      if (a.depth !== b.depth) return a.depth - b.depth;\n      if (a.order !== b.order) return a.order - b.order;\n      return a.id.localeCompare(b.id);\n    });\n    \n    for (const subgraph of subgraphs) {\n      const offset = this.draftSubgraphs[subgraph.id] ?? { x: 0, y: 0 };\n      const topLeft = this.toScreen({ x: subgraph.x + offset.x, y: subgraph.y + offset.y });\n      const bottomRight = this.toScreen({\n        x: subgraph.x + subgraph.width + offset.x,\n        y: subgraph.y + subgraph.height + offset.y,\n      });\n      const labelPoint = this.toScreen({\n        x: subgraph.labelX + offset.x,\n        y: subgraph.labelY + offset.y,\n      });\n      \n      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      g.setAttribute('class', 'subgraph');\n      g.setAttribute('data-id', subgraph.id);\n      \n      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      rect.setAttribute('x', topLeft.x);\n      rect.setAttribute('y', topLeft.y);\n      rect.setAttribute('width', bottomRight.x - topLeft.x);\n      rect.setAttribute('height', bottomRight.y - topLeft.y);\n      rect.setAttribute('rx', SUBGRAPH_BORDER_RADIUS);\n      rect.setAttribute('ry', SUBGRAPH_BORDER_RADIUS);\n      rect.setAttribute('fill', SUBGRAPH_FILL);\n      rect.setAttribute('fill-opacity', '0.7');\n      rect.setAttribute('stroke', SUBGRAPH_STROKE);\n      rect.setAttribute('stroke-width', '1.5');\n      \n      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttribute('x', labelPoint.x);\n      text.setAttribute('y', labelPoint.y);\n      text.setAttribute('fill', SUBGRAPH_LABEL_COLOR);\n      text.setAttribute('font-size', '14');\n      text.setAttribute('font-weight', '600');\n      text.setAttribute('text-anchor', 'start');\n      text.setAttribute('dominant-baseline', 'hanging');\n      text.textContent = subgraph.label;\n      \n      g.appendChild(rect);\n      g.appendChild(text);\n      \n      // Event handlers for subgraph\n      g.addEventListener('pointerdown', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.handleSubgraphPointerDown(subgraph.id, e);\n      });\n      \n      this.svg.appendChild(g);\n    }\n  }\n  \n  gatherSubgraphDescendants(rootId) {\n    const result = [];\n    const stack = [rootId];\n    const subgraphChildren = new Map();\n    \n    // Build children map\n    for (const subgraph of this.diagram.subgraphs ?? []) {\n      if (subgraph.parentId) {\n        const existing = subgraphChildren.get(subgraph.parentId);\n        if (existing) {\n          existing.push(subgraph.id);\n        } else {\n          subgraphChildren.set(subgraph.parentId, [subgraph.id]);\n        }\n      }\n    }\n    \n    while (stack.length > 0) {\n      const current = stack.pop();\n      if (!current) continue;\n      result.push(current);\n      const children = subgraphChildren.get(current);\n      if (children) {\n        for (const child of children) {\n          stack.push(child);\n        }\n      }\n    }\n    return result;\n  }\n  \n  handleSubgraphPointerDown(id, e) {\n    const diagramPoint = this.getDiagramPointFromClient(e.clientX, e.clientY);\n    if (!diagramPoint) {\n      return;\n    }\n    \n    const subgraph = this.diagram.subgraphs?.find(item => item.id === id);\n    if (!subgraph) {\n      return;\n    }\n    \n    // Get nodes in this subgraph\n    const members = this.getSubgraphNodes(id);\n    \n    if (members.length === 0) {\n      return;\n    }\n    \n    const offsetEntry = this.draftSubgraphs[id];\n    const currentTopLeft = {\n      x: subgraph.x + (offsetEntry?.x ?? 0),\n      y: subgraph.y + (offsetEntry?.y ?? 0),\n    };\n    \n    const nodeOffsets = {};\n    for (const nodeId of members) {\n      const position = this.getNodePosition(nodeId);\n      if (position) {\n        nodeOffsets[nodeId] = {\n          x: position.x - currentTopLeft.x,\n          y: position.y - currentTopLeft.y,\n        };\n      }\n    }\n    \n    if (Object.keys(nodeOffsets).length === 0) {\n      return;\n    }\n    \n    const offset = {\n      x: diagramPoint.x - currentTopLeft.x,\n      y: diagramPoint.y - currentTopLeft.y,\n    };\n    \n    const subgraphIds = this.gatherSubgraphDescendants(id);\n    \n    const memberSet = new Set(members);\n    const edgeOverrides = {};\n    for (const edge of this.diagram.edges) {\n      const baseOverride = this.draftEdges[edge.id] ?? edge.overridePoints;\n      if (!baseOverride || baseOverride.length === 0) {\n        continue;\n      }\n      if (!memberSet.has(edge.from) && !memberSet.has(edge.to)) {\n        continue;\n      }\n      edgeOverrides[edge.id] = baseOverride.map(point => ({ x: point.x, y: point.y }));\n    }\n    \n    this.dragState = {\n      type: 'subgraph',\n      id,\n      offset,\n      origin: currentTopLeft,\n      members,\n      nodeOffsets,\n      subgraphIds,\n      edgeOverrides,\n      delta: { x: 0, y: 0 },\n      moved: false,\n    };\n    \n    // Initialize draft positions\n    for (const nodeId of members) {\n      const position = this.getNodePosition(nodeId);\n      if (position) {\n        this.draftNodes[nodeId] = position;\n      }\n    }\n    \n    for (const subgraphId of subgraphIds) {\n      this.draftSubgraphs[subgraphId] = this.draftSubgraphs[subgraphId] ?? { x: 0, y: 0 };\n    }\n    \n    this.onDragStateChange(true);\n    this.onSelectNode(null);\n    this.onSelectEdge(null);\n    \n    // \n    try {\n      if (e.currentTarget && typeof e.currentTarget.setPointerCapture === 'function') {\n        e.currentTarget.setPointerCapture(e.pointerId);\n      }\n    } catch (err) {\n      console.warn('Failed to set pointer capture:', err);\n    }\n  }\n  \n  renderEdges() {\n    for (const edge of this.diagram.edges) {\n      this.renderEdge(edge);\n    }\n  }\n  \n  renderEdge(edge) {\n    const route = this.getEdgeRoute(edge);\n    if (route.length < 2) {\n      return;\n    }\n    \n    const screenRoute = route.map(p => this.toScreen(p));\n    const isSelected = this.selectedEdgeId === edge.id;\n    const color = edge.color ?? DEFAULT_EDGE_COLOR;\n    const arrowDirection = edge.arrowDirection ?? 'forward';\n    \n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    g.setAttribute('class', isSelected ? 'edge selected' : 'edge');\n    g.setAttribute('data-edge-id', edge.id);\n    \n    // Create path\n    let pathElement;\n    if (screenRoute.length === 2) {\n      pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      pathElement.setAttribute('x1', screenRoute[0].x);\n      pathElement.setAttribute('y1', screenRoute[0].y);\n      pathElement.setAttribute('x2', screenRoute[1].x);\n      pathElement.setAttribute('y2', screenRoute[1].y);\n    } else {\n      pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');\n      const points = screenRoute.map(p => `${p.x},${p.y}`).join(' ');\n      pathElement.setAttribute('points', points);\n    }\n    \n    pathElement.setAttribute('stroke', color);\n    pathElement.setAttribute('stroke-width', '2');\n    pathElement.setAttribute('fill', 'none');\n    \n    if (edge.kind === 'dashed') {\n      pathElement.setAttribute('stroke-dasharray', '8 6');\n    }\n    \n    // Arrow markers\n    if (arrowDirection === 'backward' || arrowDirection === 'both') {\n      pathElement.setAttribute('marker-start', 'url(#arrow-start)');\n    }\n    if (arrowDirection === 'forward' || arrowDirection === 'both') {\n      pathElement.setAttribute('marker-end', 'url(#arrow-end)');\n    }\n    \n    // Event handlers\n    pathElement.addEventListener('pointerdown', (e) => {\n      e.stopPropagation();\n      this.onSelectEdge(edge.id);\n    });\n    \n    pathElement.addEventListener('dblclick', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      const diagramPoint = this.getDiagramPointFromClient(e.clientX, e.clientY);\n      if (diagramPoint) {\n        this.handleEdgeDoubleClick(edge, route, diagramPoint);\n      }\n    });\n    \n    g.appendChild(pathElement);\n    \n    // Render edge label\n    if (edge.label) {\n      this.renderEdgeLabel(g, edge, route, screenRoute, isSelected, color);\n    }\n    \n    // Render handles\n    this.renderEdgeHandles(g, edge, route);\n    \n    this.svg.appendChild(g);\n  }\n  \n  renderEdgeLabel(g, edge, route, screenRoute, isSelected, color) {\n    const labelLines = normalizeLabelLines(edge.label);\n    const labelSize = measureLabelBox(labelLines);\n    const labelPoint = labelCenterForRoute(route);\n    const labelScreen = this.toScreen(labelPoint);\n    \n    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    labelGroup.setAttribute('class', 'edge-label-group');\n    labelGroup.setAttribute('transform', `translate(${labelScreen.x}, ${labelScreen.y})`);\n    \n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    rect.setAttribute('x', -labelSize.width / 2);\n    rect.setAttribute('y', -labelSize.height / 2);\n    rect.setAttribute('width', labelSize.width);\n    rect.setAttribute('height', labelSize.height);\n    rect.setAttribute('rx', EDGE_LABEL_BORDER_RADIUS);\n    rect.setAttribute('ry', EDGE_LABEL_BORDER_RADIUS);\n    rect.setAttribute('fill', EDGE_LABEL_BACKGROUND);\n    rect.setAttribute('fill-opacity', EDGE_LABEL_BACKGROUND_OPACITY);\n    rect.setAttribute('stroke', isSelected ? '#f472b6' : color);\n    rect.setAttribute('stroke-width', '1');\n    rect.setAttribute('pointer-events', 'none');\n    \n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttribute('class', 'edge-label');\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('font-size', EDGE_LABEL_FONT_SIZE);\n    text.setAttribute('dominant-baseline', 'middle');\n    text.setAttribute('pointer-events', 'none');\n    \n    if (labelLines.length === 1) {\n      text.textContent = labelLines[0];\n    } else {\n      const baselineStart = -((labelLines.length - 1) * EDGE_LABEL_LINE_HEIGHT) / 2;\n      labelLines.forEach((line, idx) => {\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.setAttribute('x', '0');\n        tspan.setAttribute('y', baselineStart + idx * EDGE_LABEL_LINE_HEIGHT);\n        tspan.setAttribute('dominant-baseline', 'middle');\n        tspan.textContent = line;\n        text.appendChild(tspan);\n      });\n    }\n    \n    labelGroup.appendChild(rect);\n    labelGroup.appendChild(text);\n    g.appendChild(labelGroup);\n  }\n  \n  renderEdgeHandles(g, edge, route) {\n    const draftOverride = this.draftEdges[edge.id];\n    const hasOverride = draftOverride !== undefined && draftOverride.length > 0;\n    const overridePoints = hasOverride ? draftOverride : [];\n    \n    const handlePoints = hasOverride\n      ? overridePoints\n      : [defaultHandleForRoute(route, route[0], route[route.length - 1])];\n    \n    handlePoints.forEach((point, index) => {\n      const screen = this.toScreen(point);\n      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      circle.setAttribute('class', hasOverride ? 'handle active' : 'handle');\n      circle.setAttribute('cx', screen.x);\n      circle.setAttribute('cy', screen.y);\n      circle.setAttribute('r', HANDLE_RADIUS);\n      circle.setAttribute('data-edge-id', edge.id);\n      circle.setAttribute('data-handle-index', index);\n      \n      circle.addEventListener('pointerdown', (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.handleHandlePointerDown(edge.id, index, handlePoints, hasOverride, e);\n      });\n      \n      circle.addEventListener('dblclick', (e) => {\n        e.stopPropagation();\n        this.onEdgeMove(edge.id, null);\n      });\n      \n      g.appendChild(circle);\n    });\n  }\n  \n  renderNodes() {\n    for (const node of this.diagram.nodes) {\n      this.renderNode(node);\n    }\n  }\n  \n  renderNode(node) {\n    const position = this.getNodePosition(node.id);\n    if (!position) {\n      return;\n    }\n    \n    const screen = this.toScreen(position);\n    const isSelected = this.selectedNodeId === node.id;\n    const nodeWidth = node.width ?? DEFAULT_NODE_WIDTH;\n    const nodeHeight = node.height ?? DEFAULT_NODE_HEIGHT;\n    \n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    g.setAttribute('class', isSelected ? 'node selected' : 'node');\n    g.setAttribute('data-node-id', node.id);\n    g.setAttribute('transform', `translate(${screen.x}, ${screen.y})`);\n    \n    // Render shape\n    this.renderNodeShape(g, node, nodeWidth, nodeHeight, isSelected);\n    \n    // Render label\n    this.renderNodeLabel(g, node, nodeWidth, nodeHeight);\n    \n    // Render image if present\n    if (node.image) {\n      this.renderNodeImage(g, node, nodeWidth, nodeHeight);\n    }\n    \n    // Event handlers\n    g.addEventListener('pointerdown', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.handleNodePointerDown(node.id, e);\n    });\n    \n    g.addEventListener('dblclick', () => {\n      this.onNodeMove(node.id, null);\n    });\n    \n    this.svg.appendChild(g);\n  }\n  \n  renderNodeShape(g, node, width, height, isSelected) {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    \n    const defaultFill = DEFAULT_NODE_COLORS[node.shape] ?? '#ffffff';\n    const fillColor = node.fillColor ?? defaultFill;\n    const strokeColor = node.strokeColor ?? DEFAULT_NODE_STROKE;\n    \n    const shapeComponents = this.createShapeComponents(node.shape, halfWidth, halfHeight, width, height, fillColor, strokeColor);\n    \n    // Add clip path if needed\n    if (node.image && shapeComponents.clip) {\n      const clipId = svgSafeId('node-clip-', node.id);\n      let defs = this.svg.querySelector('defs');\n      if (!defs) {\n        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        this.svg.insertBefore(defs, this.svg.firstChild);\n      }\n      \n      let clipPath = defs.querySelector(`clipPath[id=\"${clipId}\"]`);\n      if (!clipPath) {\n        clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');\n        clipPath.setAttribute('id', clipId);\n        clipPath.appendChild(shapeComponents.clip.cloneNode(true));\n        defs.appendChild(clipPath);\n      }\n    }\n    \n    // Append shape and outline\n    //  shape  pointer-events g\n    if (shapeComponents.shape) {\n      if (Array.isArray(shapeComponents.shape)) {\n        shapeComponents.shape.forEach(el => {\n          el.setAttribute('pointer-events', 'all');\n          g.appendChild(el);\n        });\n      } else {\n        shapeComponents.shape.setAttribute('pointer-events', 'all');\n        g.appendChild(shapeComponents.shape);\n      }\n    }\n    \n    if (shapeComponents.outline) {\n      if (Array.isArray(shapeComponents.outline)) {\n        shapeComponents.outline.forEach(el => {\n          el.setAttribute('pointer-events', 'none');\n          g.appendChild(el);\n        });\n      } else {\n        shapeComponents.outline.setAttribute('pointer-events', 'none');\n        g.appendChild(shapeComponents.outline);\n      }\n    }\n  }\n  \n  createShapeComponents(shape, halfWidth, halfHeight, width, height, fillColor, strokeColor) {\n    const createRect = (rx, ry) => {\n      const el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      el.setAttribute('x', -halfWidth);\n      el.setAttribute('y', -halfHeight);\n      el.setAttribute('width', width);\n      el.setAttribute('height', height);\n      el.setAttribute('rx', rx);\n      el.setAttribute('ry', ry);\n      return el;\n    };\n    \n    const createEllipse = () => {\n      const el = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n      el.setAttribute('cx', '0');\n      el.setAttribute('cy', '0');\n      el.setAttribute('rx', halfWidth);\n      el.setAttribute('ry', halfHeight);\n      return el;\n    };\n    \n    const createPolygon = (points) => {\n      const el = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n      el.setAttribute('points', polygonPoints(points));\n      return el;\n    };\n    \n    const createPath = (d) => {\n      const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      el.setAttribute('d', d);\n      return el;\n    };\n    \n    const createLine = (x1, y1, x2, y2) => {\n      const el = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      el.setAttribute('x1', x1);\n      el.setAttribute('y1', y1);\n      el.setAttribute('x2', x2);\n      el.setAttribute('y2', y2);\n      el.setAttribute('stroke', strokeColor);\n      el.setAttribute('stroke-width', '2');\n      return el;\n    };\n    \n    switch (shape) {\n      case 'rectangle': {\n        const shapeEl = createRect(8, 8);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createRect(8, 8);\n        const outlineEl = createRect(8, 8);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'stadium': {\n        const shapeEl = createRect(30, 30);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createRect(30, 30);\n        const outlineEl = createRect(30, 30);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'circle': {\n        const shapeEl = createEllipse();\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createEllipse();\n        const outlineEl = createEllipse();\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'double-circle': {\n        const innerRx = Math.max(halfWidth - 6, halfWidth * 0.65);\n        const innerRy = Math.max(halfHeight - 6, halfHeight * 0.65);\n        const shapeEl = createEllipse();\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createEllipse();\n        const outerOutline = createEllipse();\n        outerOutline.setAttribute('fill', 'none');\n        outerOutline.setAttribute('stroke', strokeColor);\n        outerOutline.setAttribute('stroke-width', '2');\n        const innerOutline = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\n        innerOutline.setAttribute('cx', '0');\n        innerOutline.setAttribute('cy', '0');\n        innerOutline.setAttribute('rx', innerRx);\n        innerOutline.setAttribute('ry', innerRy);\n        innerOutline.setAttribute('fill', 'none');\n        innerOutline.setAttribute('stroke', strokeColor);\n        innerOutline.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: [outerOutline, innerOutline] };\n      }\n      \n      case 'diamond': {\n        const points = [[0, -halfHeight], [halfWidth, 0], [0, halfHeight], [-halfWidth, 0]];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'subroutine': {\n        const inset = 12;\n        const shapeEl = createRect(8, 8);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createRect(8, 8);\n        const outlineEl = createRect(8, 8);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        const line1 = createLine(-halfWidth + inset, -halfHeight, -halfWidth + inset, halfHeight);\n        const line2 = createLine(halfWidth - inset, -halfHeight, halfWidth - inset, halfHeight);\n        return { shape: shapeEl, clip: clipEl, outline: [outlineEl, line1, line2] };\n      }\n      \n      case 'cylinder': {\n        const rx = halfWidth;\n        const ry = height / 6;\n        const top = -halfHeight;\n        const bottom = halfHeight;\n        const topCenter = top + ry;\n        const bottomCenter = bottom - ry;\n        const bodyPath = `M ${-halfWidth},${topCenter} A ${rx},${ry} 0 0 1 ${halfWidth},${topCenter} L ${halfWidth},${bottomCenter} A ${rx},${ry} 0 0 1 ${-halfWidth},${bottomCenter} Z`;\n        const topPath = `M ${-halfWidth},${topCenter} A ${rx},${ry} 0 0 1 ${halfWidth},${topCenter}`;\n        const shapeEl = createPath(bodyPath);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPath(bodyPath);\n        const bodyOutline = createPath(bodyPath);\n        bodyOutline.setAttribute('fill', 'none');\n        bodyOutline.setAttribute('stroke', strokeColor);\n        bodyOutline.setAttribute('stroke-width', '2');\n        const topOutline = createPath(topPath);\n        topOutline.setAttribute('fill', 'none');\n        topOutline.setAttribute('stroke', strokeColor);\n        topOutline.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: [bodyOutline, topOutline] };\n      }\n      \n      case 'hexagon': {\n        const offset = width * 0.25;\n        const points = [\n          [-halfWidth + offset, -halfHeight],\n          [halfWidth - offset, -halfHeight],\n          [halfWidth, 0],\n          [halfWidth - offset, halfHeight],\n          [-halfWidth + offset, halfHeight],\n          [-halfWidth, 0],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'parallelogram': {\n        const skew = height * 0.35;\n        const points = [\n          [-halfWidth + skew, -halfHeight],\n          [halfWidth, -halfHeight],\n          [halfWidth - skew, halfHeight],\n          [-halfWidth, halfHeight],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'parallelogram-alt': {\n        const skew = height * 0.35;\n        const points = [\n          [-halfWidth, -halfHeight],\n          [halfWidth - skew, -halfHeight],\n          [halfWidth, halfHeight],\n          [-halfWidth + skew, halfHeight],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'trapezoid': {\n        const topInset = width * 0.22;\n        const bottomInset = width * 0.08;\n        const points = [\n          [-halfWidth + topInset, -halfHeight],\n          [halfWidth - topInset, -halfHeight],\n          [halfWidth - bottomInset, halfHeight],\n          [-halfWidth + bottomInset, halfHeight],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'trapezoid-alt': {\n        const topInset = width * 0.08;\n        const bottomInset = width * 0.22;\n        const points = [\n          [-halfWidth + topInset, -halfHeight],\n          [halfWidth - topInset, -halfHeight],\n          [halfWidth - bottomInset, halfHeight],\n          [-halfWidth + bottomInset, halfHeight],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      case 'asymmetric': {\n        const skew = height * 0.45;\n        const points = [\n          [-halfWidth, -halfHeight],\n          [halfWidth - skew, -halfHeight],\n          [halfWidth, 0],\n          [halfWidth - skew, halfHeight],\n          [-halfWidth, halfHeight],\n        ];\n        const shapeEl = createPolygon(points);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createPolygon(points);\n        const outlineEl = createPolygon(points);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n      \n      default: {\n        // Default to rectangle\n        const shapeEl = createRect(8, 8);\n        shapeEl.setAttribute('fill', fillColor);\n        const clipEl = createRect(8, 8);\n        const outlineEl = createRect(8, 8);\n        outlineEl.setAttribute('fill', 'none');\n        outlineEl.setAttribute('stroke', strokeColor);\n        outlineEl.setAttribute('stroke-width', '2');\n        return { shape: shapeEl, clip: clipEl, outline: outlineEl };\n      }\n    }\n  }\n  \n  renderNodeLabel(g, node, width, height) {\n    const labelLines = normalizeLabelLines(node.label);\n    const hasLabel = labelLines.length > 0;\n    if (!hasLabel) {\n      return;\n    }\n    \n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const imageData = node.image ?? null;\n    const textColor = node.textColor ?? DEFAULT_NODE_TEXT;\n    \n    // Calculate label area for nodes with images\n    const labelLineCount = Math.max(1, labelLines.length);\n    const labelAreaHeight = imageData\n      ? Math.max(NODE_LABEL_HEIGHT, labelLineCount * NODE_TEXT_LINE_HEIGHT)\n      : 0;\n    \n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttribute('fill', textColor);\n    text.setAttribute('font-size', '14');\n    text.setAttribute('text-anchor', 'middle');\n    text.setAttribute('pointer-events', 'none');\n    \n    if (imageData && labelAreaHeight > 0) {\n      // Node with image - label at top\n      if (labelLines.length === 1) {\n        const baseline = -halfHeight + labelAreaHeight / 2;\n        text.setAttribute('x', '0');\n        text.setAttribute('y', baseline);\n        text.setAttribute('dominant-baseline', 'middle');\n        text.textContent = labelLines[0];\n      } else {\n        const totalTextHeight = NODE_TEXT_LINE_HEIGHT * labelLines.length;\n        const labelTop = -halfHeight;\n        const startY = labelTop + (labelAreaHeight - totalTextHeight) / 2 + NODE_TEXT_LINE_HEIGHT / 2;\n        labelLines.forEach((line, idx) => {\n          const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n          tspan.setAttribute('x', '0');\n          tspan.setAttribute('y', startY + idx * NODE_TEXT_LINE_HEIGHT);\n          tspan.setAttribute('dominant-baseline', 'middle');\n          tspan.textContent = line;\n          text.appendChild(tspan);\n        });\n      }\n    } else {\n      // Node without image - label centered\n      if (labelLines.length === 1) {\n        text.setAttribute('x', '0');\n        text.setAttribute('y', '0');\n        text.setAttribute('dominant-baseline', 'middle');\n        text.textContent = labelLines[0];\n      } else {\n        const startY = -NODE_TEXT_LINE_HEIGHT * (labelLines.length - 1) / 2;\n        labelLines.forEach((line, idx) => {\n          const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n          tspan.setAttribute('x', '0');\n          tspan.setAttribute('y', startY + idx * NODE_TEXT_LINE_HEIGHT);\n          tspan.setAttribute('dominant-baseline', 'middle');\n          tspan.textContent = line;\n          text.appendChild(tspan);\n        });\n      }\n    }\n    \n    g.appendChild(text);\n  }\n  \n  renderNodeImage(g, node, width, height) {\n    const imageData = node.image;\n    if (!imageData) {\n      return;\n    }\n    \n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const imagePadding = Math.max(0, Number.isFinite(imageData.padding) ? imageData.padding : 0);\n    \n    // Calculate label area\n    const labelLines = normalizeLabelLines(node.label);\n    const labelLineCount = Math.max(1, labelLines.length);\n    const labelAreaHeight = Math.max(NODE_LABEL_HEIGHT, labelLineCount * NODE_TEXT_LINE_HEIGHT);\n    \n    // Calculate image dimensions\n    const imageHeight = Math.max(0, height - labelAreaHeight - imagePadding * 2);\n    const imageWidth = Math.max(0, width - imagePadding * 2);\n    \n    if (imageWidth <= 0.5 || imageHeight <= 0.5) {\n      return;\n    }\n    \n    // Render label background if needed\n    const defaultFill = DEFAULT_NODE_COLORS[node.shape] ?? '#ffffff';\n    const baseFillColor = node.fillColor ?? defaultFill;\n    const labelFillColor = node.labelFillColor ?? baseFillColor;\n    \n    if (labelAreaHeight > 0) {\n      const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n      labelBg.setAttribute('x', -halfWidth);\n      labelBg.setAttribute('y', -halfHeight);\n      labelBg.setAttribute('width', width);\n      labelBg.setAttribute('height', labelAreaHeight);\n      labelBg.setAttribute('fill', labelFillColor);\n      labelBg.setAttribute('pointer-events', 'none');\n      const clipId = svgSafeId('node-clip-', node.id);\n      labelBg.setAttribute('clip-path', `url(#${clipId})`);\n      g.appendChild(labelBg);\n    }\n    \n    // Render image\n    const imageFillColor = node.imageFillColor ?? '#ffffff';\n    const imageBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    imageBg.setAttribute('x', -halfWidth + imagePadding);\n    imageBg.setAttribute('y', -halfHeight + labelAreaHeight + imagePadding);\n    imageBg.setAttribute('width', imageWidth);\n    imageBg.setAttribute('height', imageHeight);\n    imageBg.setAttribute('fill', imageFillColor);\n    imageBg.setAttribute('pointer-events', 'none');\n    g.appendChild(imageBg);\n    \n    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n    image.setAttribute('pointer-events', 'none');\n    image.setAttribute('x', -halfWidth + imagePadding);\n    image.setAttribute('y', -halfHeight + labelAreaHeight + imagePadding);\n    image.setAttribute('width', imageWidth);\n    image.setAttribute('height', imageHeight);\n    image.setAttribute('href', `data:${imageData.mimeType};base64,${imageData.data}`);\n    image.setAttribute('preserveAspectRatio', 'xMidYMid slice');\n    \n    const clipId = svgSafeId('node-clip-', node.id);\n    image.setAttribute('clip-path', `url(#${clipId})`);\n    \n    g.appendChild(image);\n  }\n  \n  renderAlignmentGuides() {\n    if (!this.alignmentGuides || (!this.alignmentGuides.vertical && !this.alignmentGuides.horizontal)) {\n      return;\n    }\n    \n    if (this.alignmentGuides.vertical) {\n      const guide = this.alignmentGuides.vertical;\n      const start = this.toScreen({ x: guide.x, y: guide.y1 });\n      const end = this.toScreen({ x: guide.x, y: guide.y2 });\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.setAttribute('class', `alignment-guide alignment-guide-vertical alignment-guide-${guide.kind}`);\n      line.setAttribute('x1', start.x);\n      line.setAttribute('y1', start.y);\n      line.setAttribute('x2', end.x);\n      line.setAttribute('y2', end.y);\n      this.svg.appendChild(line);\n    }\n    \n    if (this.alignmentGuides.horizontal) {\n      const guide = this.alignmentGuides.horizontal;\n      const start = this.toScreen({ x: guide.x1, y: guide.y });\n      const end = this.toScreen({ x: guide.x2, y: guide.y });\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.setAttribute('class', `alignment-guide alignment-guide-horizontal alignment-guide-${guide.kind}`);\n      line.setAttribute('x1', start.x);\n      line.setAttribute('y1', start.y);\n      line.setAttribute('x2', end.x);\n      line.setAttribute('y2', end.y);\n      this.svg.appendChild(line);\n    }\n  }\n  \n  // Event handlers\n  handleCanvasPointerDown(e) {\n    if (e.target === this.svg) {\n      this.onSelectNode(null);\n      this.onSelectEdge(null);\n    }\n  }\n  \n  handleNodePointerDown(nodeId, e) {\n    const diagramPoint = this.getDiagramPointFromClient(e.clientX, e.clientY);\n    if (!diagramPoint) {\n      return;\n    }\n    \n    const position = this.getNodePosition(nodeId);\n    if (!position) {\n      return;\n    }\n    \n    const offset = {\n      x: diagramPoint.x - position.x,\n      y: diagramPoint.y - position.y,\n    };\n    \n    this.dragState = {\n      type: 'node',\n      id: nodeId,\n      offset,\n      current: position,\n      moved: false,\n    };\n    \n    this.draftNodes[nodeId] = position;\n    this.onDragStateChange(true);\n    this.onSelectNode(nodeId);\n    \n    // \n    try {\n      if (e.currentTarget && typeof e.currentTarget.setPointerCapture === 'function') {\n        e.currentTarget.setPointerCapture(e.pointerId);\n      }\n    } catch (err) {\n      console.warn('Failed to set pointer capture:', err);\n    }\n  }\n  \n  handleHandlePointerDown(edgeId, index, handlePoints, hasOverride, e) {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    const basePoints = hasOverride\n      ? handlePoints.map(p => ({ ...p }))\n      : [handlePoints[index] ?? handlePoints[0]];\n    \n    this.dragState = {\n      type: 'edge',\n      id: edgeId,\n      index: hasOverride ? index : 0,\n      points: basePoints,\n      moved: false,\n      hasOverride,\n    };\n    \n    this.draftEdges[edgeId] = basePoints;\n    this.onDragStateChange(true);\n    this.onSelectEdge(edgeId);\n    \n    // \n    try {\n      if (e.currentTarget && typeof e.currentTarget.setPointerCapture === 'function') {\n        e.currentTarget.setPointerCapture(e.pointerId);\n      }\n    } catch (err) {\n      console.warn('Failed to set pointer capture:', err);\n    }\n  }\n  \n  handleEdgeDoubleClick(edge, route, diagramPoint) {\n    const handlePoints = this.draftEdges[edge.id] ?? edge.overridePoints ?? [];\n    const basePoints = handlePoints.map(p => ({ ...p }));\n    \n    if (basePoints.some(p => isClose(p, diagramPoint))) {\n      return;\n    }\n    \n    if (basePoints.length === 0) {\n      basePoints.push(diagramPoint);\n    } else {\n      let bestSegment = 0;\n      let bestDistance = Number.POSITIVE_INFINITY;\n      for (let i = 0; i < route.length - 1; i++) {\n        const distance = distanceToSegment(diagramPoint, route[i], route[i + 1]);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestSegment = i;\n        }\n      }\n      basePoints.splice(Math.min(bestSegment, basePoints.length), 0, diagramPoint);\n    }\n    \n    this.draftEdges[edge.id] = basePoints;\n    this.onEdgeMove(edge.id, basePoints);\n    this.onSelectEdge(edge.id);\n  }\n  \n  handlePointerMove(e) {\n    if (!this.dragState) {\n      return;\n    }\n    \n    const diagramPoint = this.getDiagramPointFromClient(e.clientX, e.clientY);\n    if (!diagramPoint) {\n      return;\n    }\n    \n    if (this.dragState.type === 'node') {\n      const proposed = {\n        x: diagramPoint.x - this.dragState.offset.x,\n        y: diagramPoint.y - this.dragState.offset.y,\n      };\n      \n      // Compute alignment\n      const nodeEntries = Array.from(this.getFinalPositions().entries());\n      const alignment = computeNodeAlignment(\n        this.dragState.id,\n        proposed,\n        nodeEntries,\n        ALIGN_THRESHOLD,\n        this.nodeDimensions\n      );\n      \n      const snappedPosition = {\n        x: alignment.appliedX ? alignment.position.x : snapToGrid(alignment.position.x, GRID_SIZE),\n        y: alignment.appliedY ? alignment.position.y : snapToGrid(alignment.position.y, GRID_SIZE),\n      };\n      \n      if (!guidesEqual(this.alignmentGuides, alignment.guides)) {\n        this.alignmentGuides = alignment.guides;\n      }\n      \n      this.dragState.current = snappedPosition;\n      this.dragState.moved = true;\n      this.draftNodes[this.dragState.id] = snappedPosition;\n      this.render();\n    } else if (this.dragState.type === 'edge') {\n      const handleId = `edge:${this.dragState.id}:handle:${this.dragState.index}`;\n      const nodeEntries = Array.from(this.getFinalPositions().entries());\n      const alignment = computeNodeAlignment(\n        handleId,\n        diagramPoint,\n        nodeEntries,\n        ALIGN_THRESHOLD,\n        this.nodeDimensions\n      );\n      \n      const snappedPoint = {\n        x: alignment.appliedX ? alignment.position.x : snapToGrid(alignment.position.x, GRID_SIZE),\n        y: alignment.appliedY ? alignment.position.y : snapToGrid(alignment.position.y, GRID_SIZE),\n      };\n      \n      if (!guidesEqual(this.alignmentGuides, alignment.guides)) {\n        this.alignmentGuides = alignment.guides;\n      }\n      \n      const nextPoints = this.dragState.points.map((p, idx) =>\n        idx === this.dragState.index ? snappedPoint : p\n      );\n      \n      this.dragState.points = nextPoints;\n      this.dragState.moved = true;\n      this.draftEdges[this.dragState.id] = nextPoints;\n      this.render();\n    } else if (this.dragState.type === 'subgraph') {\n      const targetTopLeft = {\n        x: diagramPoint.x - this.dragState.offset.x,\n        y: diagramPoint.y - this.dragState.offset.y,\n      };\n      const proposedDelta = {\n        x: targetTopLeft.x - this.dragState.origin.x,\n        y: targetTopLeft.y - this.dragState.origin.y,\n      };\n      \n      // Simplified subgraph delta resolution (full implementation would handle separation)\n      const resolvedDelta = proposedDelta;\n      const newTopLeft = {\n        x: this.dragState.origin.x + resolvedDelta.x,\n        y: this.dragState.origin.y + resolvedDelta.y,\n      };\n      const moved = this.dragState.moved ||\n        Math.abs(resolvedDelta.x) > EPSILON ||\n        Math.abs(resolvedDelta.y) > EPSILON;\n      \n      this.alignmentGuides = {};\n      this.dragState.delta = resolvedDelta;\n      this.dragState.moved = moved;\n      this.dragState.offset = {\n        x: diagramPoint.x - newTopLeft.x,\n        y: diagramPoint.y - newTopLeft.y,\n      };\n      \n      // Update draft nodes\n      for (const nodeId of this.dragState.members) {\n        const offset = this.dragState.nodeOffsets[nodeId];\n        if (offset) {\n          this.draftNodes[nodeId] = {\n            x: newTopLeft.x + offset.x,\n            y: newTopLeft.y + offset.y,\n          };\n        }\n      }\n      \n      // Update draft subgraphs\n      for (const subgraphId of this.dragState.subgraphIds) {\n        this.draftSubgraphs[subgraphId] = { x: resolvedDelta.x, y: resolvedDelta.y };\n      }\n      \n      // Update draft edges\n      if (Object.keys(this.dragState.edgeOverrides).length > 0) {\n        for (const [edgeId, basePoints] of Object.entries(this.dragState.edgeOverrides)) {\n          this.draftEdges[edgeId] = basePoints.map(point => ({\n            x: point.x + resolvedDelta.x,\n            y: point.y + resolvedDelta.y,\n          }));\n        }\n      }\n      \n      this.render();\n    }\n  }\n  \n  getFinalPositions() {\n    const map = new Map();\n    for (const node of this.diagram.nodes) {\n      const override = this.draftNodes[node.id] ?? node.overridePosition ?? node.renderedPosition;\n      map.set(node.id, override);\n    }\n    return map;\n  }\n  \n  handlePointerUp(e) {\n    if (!this.dragState) {\n      return;\n    }\n    \n    const currentDrag = this.dragState;\n    this.onDragStateChange(false);\n    this.alignmentGuides = {};\n    \n    if (currentDrag.type === 'node') {\n      if (currentDrag.moved) {\n        const node = this.diagram.nodes.find(n => n.id === currentDrag.id);\n        const current = currentDrag.current;\n        const auto = node?.autoPosition;\n        const result = auto && current && isClose(current, auto, EPSILON) ? null : current;\n        this.onNodeMove(currentDrag.id, result);\n      }\n      delete this.draftNodes[currentDrag.id];\n    } else if (currentDrag.type === 'edge') {\n      if (currentDrag.moved) {\n        const normalized = currentDrag.points.map(p => ({ ...p }));\n        const shouldClear = normalized.length === 0;\n        this.onEdgeMove(currentDrag.id, shouldClear ? null : normalized);\n      }\n      delete this.draftEdges[currentDrag.id];\n    } else if (currentDrag.type === 'subgraph') {\n      if (currentDrag.moved) {\n        const nodeUpdates = {};\n        const edgeUpdates = {};\n        const finalTopLeft = {\n          x: currentDrag.origin.x + currentDrag.delta.x,\n          y: currentDrag.origin.y + currentDrag.delta.y,\n        };\n        \n        for (const nodeId of currentDrag.members) {\n          const offset = currentDrag.nodeOffsets[nodeId];\n          if (!offset) continue;\n          const node = this.diagram.nodes.find(n => n.id === nodeId);\n          const finalPoint = {\n            x: finalTopLeft.x + offset.x,\n            y: finalTopLeft.y + offset.y,\n          };\n          const auto = node?.autoPosition;\n          nodeUpdates[nodeId] = auto && isClose(finalPoint, auto, EPSILON) ? null : finalPoint;\n        }\n        \n        for (const [edgeId, basePoints] of Object.entries(currentDrag.edgeOverrides)) {\n          if (!basePoints || basePoints.length === 0) continue;\n          edgeUpdates[edgeId] = basePoints.map(point => ({\n            x: point.x + currentDrag.delta.x,\n            y: point.y + currentDrag.delta.y,\n          }));\n        }\n        \n        if (this.onLayoutUpdate) {\n          const payload = {};\n          if (Object.keys(nodeUpdates).length > 0) {\n            payload.nodes = nodeUpdates;\n          }\n          if (Object.keys(edgeUpdates).length > 0) {\n            payload.edges = {};\n            for (const [edgeId, points] of Object.entries(edgeUpdates)) {\n              payload.edges[edgeId] = { points };\n            }\n          }\n          if (payload.nodes || payload.edges) {\n            this.onLayoutUpdate(payload);\n          }\n        }\n      }\n      \n      for (const nodeId of currentDrag.members) {\n        delete this.draftNodes[nodeId];\n      }\n      for (const edgeId of Object.keys(currentDrag.edgeOverrides)) {\n        delete this.draftEdges[edgeId];\n      }\n      for (const subgraphId of currentDrag.subgraphIds) {\n        delete this.draftSubgraphs[subgraphId];\n      }\n    }\n    \n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      e.currentTarget.releasePointerCapture(e.pointerId);\n    }\n    \n    this.dragState = null;\n    this.render();\n  }\n  \n  handlePointerCancel(e) {\n    if (!this.dragState) {\n      return;\n    }\n    \n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      e.currentTarget.releasePointerCapture(e.pointerId);\n    }\n    \n    this.onDragStateChange(false);\n    this.alignmentGuides = {};\n    \n    if (this.dragState.type === 'node') {\n      delete this.draftNodes[this.dragState.id];\n    } else if (this.dragState.type === 'edge') {\n      delete this.draftEdges[this.dragState.id];\n    } else if (this.dragState.type === 'subgraph') {\n      for (const nodeId of this.dragState.members) {\n        delete this.draftNodes[nodeId];\n      }\n      for (const edgeId of Object.keys(this.dragState.edgeOverrides)) {\n        delete this.draftEdges[edgeId];\n      }\n      for (const subgraphId of this.dragState.subgraphIds) {\n        delete this.draftSubgraphs[subgraphId];\n      }\n    }\n    \n    this.dragState = null;\n    this.render();\n  }\n  \n  handleKeyDown(e) {\n    if (this.selectedNodeId && !this.dragState) {\n      const active = document.activeElement;\n      if (active && (\n        active.tagName === 'TEXTAREA' ||\n        active.tagName === 'INPUT' ||\n        active.isContentEditable\n      )) {\n        return;\n      }\n      \n      const { key } = e;\n      if (key !== 'ArrowUp' && key !== 'ArrowDown' && key !== 'ArrowLeft' && key !== 'ArrowRight') {\n        return;\n      }\n      \n      const current = this.getNodePosition(this.selectedNodeId);\n      if (!current) {\n        return;\n      }\n      \n      const step = e.shiftKey ? GRID_SIZE : 1;\n      let deltaX = 0;\n      let deltaY = 0;\n      \n      switch (key) {\n        case 'ArrowUp':\n          deltaY = -step;\n          break;\n        case 'ArrowDown':\n          deltaY = step;\n          break;\n        case 'ArrowLeft':\n          deltaX = -step;\n          break;\n        case 'ArrowRight':\n          deltaX = step;\n          break;\n      }\n      \n      if (deltaX === 0 && deltaY === 0) {\n        return;\n      }\n      \n      e.preventDefault();\n      \n      const next = {\n        x: current.x + deltaX,\n        y: current.y + deltaY,\n      };\n      const adjusted = e.shiftKey\n        ? { x: snapToGrid(next.x, GRID_SIZE), y: snapToGrid(next.y, GRID_SIZE) }\n        : next;\n      \n      this.draftNodes[this.selectedNodeId] = adjusted;\n      this.onNodeMove(this.selectedNodeId, adjusted);\n      this.render();\n    }\n    \n    // Delete key\n    if ((e.key === 'Delete' || e.key === 'Backspace') && !this.dragState) {\n      const active = document.activeElement;\n      if (active && (\n        active.tagName === 'TEXTAREA' ||\n        active.tagName === 'INPUT' ||\n        active.isContentEditable\n      )) {\n        return;\n      }\n      \n      if (this.selectedNodeId) {\n        e.preventDefault();\n        this.onDeleteNode(this.selectedNodeId);\n      } else if (this.selectedEdgeId) {\n        e.preventDefault();\n        this.onDeleteEdge(this.selectedEdgeId);\n      }\n    }\n  }\n  \n  closeContextMenu() {\n    this.contextMenu = { visible: false, x: 0, y: 0, target: null };\n  }\n  \n  destroy() {\n    // Cleanup\n    if (this.wrapper && this.wrapper.parentNode) {\n      this.wrapper.parentNode.removeChild(this.wrapper);\n    }\n  }\n}\n\n","// State Manager - replaces React Hooks\n\nexport class StateManager {\n  constructor() {\n    this.diagram = null;\n    this.loading = true;\n    this.error = null;\n    this.saving = false;\n    this.source = \"\";\n    this.sourceDraft = \"\";\n    this.sourceSaving = false;\n    this.sourceError = null;\n    this.selectedNodeId = null;\n    this.selectedEdgeId = null;\n    this.imagePaddingValue = \"\";\n    this.dragging = false;\n    \n    // \n    this.listeners = new Set();\n    \n    // \n    this.saveTimer = null;\n    this.lastSubmittedSource = null;\n  }\n  \n  // \n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n  \n  // \n  notify() {\n    this.listeners.forEach(listener => {\n      try {\n        listener(this.getState());\n      } catch (error) {\n        console.error('State listener error:', error);\n      }\n    });\n  }\n  \n  // \n  getState() {\n    return {\n      diagram: this.diagram,\n      loading: this.loading,\n      error: this.error,\n      saving: this.saving,\n      source: this.source,\n      sourceDraft: this.sourceDraft,\n      sourceSaving: this.sourceSaving,\n      sourceError: this.sourceError,\n      selectedNodeId: this.selectedNodeId,\n      selectedEdgeId: this.selectedEdgeId,\n      imagePaddingValue: this.imagePaddingValue,\n      dragging: this.dragging,\n    };\n  }\n  \n  // \n  setState(updates) {\n    let changed = false;\n    for (const [key, value] of Object.entries(updates)) {\n      if (this[key] !== value) {\n        this[key] = value;\n        changed = true;\n      }\n    }\n    if (changed) {\n      this.notify();\n    }\n  }\n  \n  // \n  getSelectedNode() {\n    if (!this.diagram || !this.selectedNodeId) {\n      return null;\n    }\n    return this.diagram.nodes.find(node => node.id === this.selectedNodeId) ?? null;\n  }\n  \n  // \n  getSelectedEdge() {\n    if (!this.diagram || !this.selectedEdgeId) {\n      return null;\n    }\n    return this.diagram.edges.find(edge => edge.id === this.selectedEdgeId) ?? null;\n  }\n  \n  // \n  hasOverrides() {\n    if (!this.diagram) {\n      return false;\n    }\n    return (\n      this.diagram.nodes.some(node => node.overridePosition) ||\n      this.diagram.edges.some(edge => edge.overridePoints && edge.overridePoints.length > 0)\n    );\n  }\n  \n  // \n  clearSaveTimer() {\n    if (this.saveTimer !== null) {\n      clearTimeout(this.saveTimer);\n      this.saveTimer = null;\n    }\n  }\n  \n  // \n  setSaveTimer(callback, delay) {\n    this.clearSaveTimer();\n    this.saveTimer = setTimeout(callback, delay);\n  }\n}\n\n","// Type definitions (converted from TypeScript)\n\nexport const DEFAULT_NODE_COLORS = {\n  rectangle: \"#FDE68A\",\n  stadium: \"#C4F1F9\",\n  circle: \"#E9D8FD\",\n  \"double-circle\": \"#BFDBFE\",\n  diamond: \"#FBCFE8\",\n  subroutine: \"#FED7AA\",\n  cylinder: \"#BBF7D0\",\n  hexagon: \"#FCA5A5\",\n  parallelogram: \"#C7D2FE\",\n  \"parallelogram-alt\": \"#A5F3FC\",\n  trapezoid: \"#FCE7F3\",\n  \"trapezoid-alt\": \"#FCD5CE\",\n  asymmetric: \"#F5D0FE\",\n};\n\nexport const DEFAULT_EDGE_COLOR = \"#2d3748\";\nexport const DEFAULT_NODE_TEXT = \"#1a202c\";\nexport const DEFAULT_NODE_STROKE = \"#2d3748\";\n\nexport const LINE_STYLE_OPTIONS = [\n  { value: \"solid\", label: \"\" },\n  { value: \"dashed\", label: \"\" },\n];\n\nexport const ARROW_DIRECTION_OPTIONS = [\n  { value: \"forward\", label: \"\" },\n  { value: \"backward\", label: \"\" },\n  { value: \"both\", label: \"\" },\n  { value: \"none\", label: \"\" },\n];\n\nexport const HEX_COLOR_RE = /^#([0-9a-f]{6})$/i;\nexport const PADDING_PRECISION = 1000;\nexport const PADDING_EPSILON = 0.001;\nexport const MAX_IMAGE_FILE_BYTES = 10 * 1024 * 1024;\n\n// Canvas constants\nexport const DEFAULT_NODE_WIDTH = 140;\nexport const DEFAULT_NODE_HEIGHT = 60;\nexport const NODE_LABEL_HEIGHT = 28;\nexport const NODE_TEXT_LINE_HEIGHT = 16;\nexport const LAYOUT_MARGIN = 80;\nexport const HANDLE_RADIUS = 6;\nexport const EPSILON = 0.5;\nexport const GRID_SIZE = 10;\nexport const ALIGN_THRESHOLD = 8;\nexport const BOUNDS_SMOOTHING = 0.18;\nexport const BOUNDS_EPSILON = 0.5;\nexport const EDGE_LABEL_MIN_WIDTH = 36;\nexport const EDGE_LABEL_MIN_HEIGHT = 28;\nexport const EDGE_LABEL_LINE_HEIGHT = 16;\nexport const EDGE_LABEL_FONT_SIZE = 13;\nexport const EDGE_LABEL_HORIZONTAL_PADDING = 16;\nexport const EDGE_LABEL_VERTICAL_PADDING = 12;\nexport const EDGE_LABEL_VERTICAL_OFFSET = 10;\nexport const EDGE_LABEL_BORDER_RADIUS = 6;\nexport const EDGE_LABEL_BACKGROUND = \"white\";\nexport const EDGE_LABEL_BACKGROUND_OPACITY = 0.96;\nexport const SUBGRAPH_FILL = \"#edf2f7\";\nexport const SUBGRAPH_STROKE = \"#a0aec0\";\nexport const SUBGRAPH_LABEL_COLOR = \"#2d3748\";\nexport const SUBGRAPH_BORDER_RADIUS = 16;\nexport const SUBGRAPH_SEPARATION = 140;\n\n","// Utility functions\n\nexport function formatByteSize(bytes) {\n  if (!Number.isFinite(bytes) || bytes <= 0) {\n    return \"0 B\";\n  }\n  const units = [\"B\", \"KB\", \"MB\", \"GB\"];\n  let value = bytes;\n  let unitIndex = 0;\n  while (value >= 1024 && unitIndex < units.length - 1) {\n    value /= 1024;\n    unitIndex += 1;\n  }\n  const decimals = unitIndex === 0 ? 0 : value < 10 ? 1 : 0;\n  return `${value.toFixed(decimals)} ${units[unitIndex]}`;\n}\n\nexport function blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const result = reader.result;\n      if (typeof result !== \"string\") {\n        reject(new Error(\"Failed to encode image.\"));\n        return;\n      }\n      const commaIndex = result.indexOf(\",\");\n      if (commaIndex === -1) {\n        reject(new Error(\"Failed to encode image.\"));\n        return;\n      }\n      resolve(result.slice(commaIndex + 1));\n    };\n    reader.onerror = () => {\n      reject(reader.error ?? new Error(\"Failed to encode image.\"));\n    };\n    reader.readAsDataURL(blob);\n  });\n}\n\nexport function loadImageFromBlob(blob) {\n  return new Promise((resolve, reject) => {\n    const url = URL.createObjectURL(blob);\n    const image = new Image();\n    image.onload = () => {\n      URL.revokeObjectURL(url);\n      resolve(image);\n    };\n    image.onerror = () => {\n      URL.revokeObjectURL(url);\n      reject(new Error(\"Unable to read image file.\"));\n    };\n    image.src = url;\n  });\n}\n\nexport async function resizeImageToLimit(image, sourceBlob, maxBytes) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  if (!context) {\n    throw new Error(\"Canvas support is required to resize images.\");\n  }\n\n  if (sourceBlob.size <= maxBytes) {\n    return { blob: sourceBlob, resized: false, fits: true };\n  }\n\n  const MIN_SCALE = 0.05;\n  const STEP = 0.75;\n\n  let currentScale = Math.sqrt(maxBytes / sourceBlob.size);\n  if (!Number.isFinite(currentScale) || currentScale >= 0.99) {\n    currentScale = 0.95;\n  }\n  currentScale = Math.min(currentScale, 0.95);\n  currentScale = Math.max(currentScale, MIN_SCALE);\n\n  let blob = null;\n  let fits = false;\n  let attempts = 0;\n\n  while (attempts < 10 && currentScale >= MIN_SCALE) {\n    const targetWidth = Math.max(1, Math.round(image.width * currentScale));\n    const targetHeight = Math.max(1, Math.round(image.height * currentScale));\n\n    canvas.width = targetWidth;\n    canvas.height = targetHeight;\n\n    context.clearRect(0, 0, targetWidth, targetHeight);\n    context.drawImage(image, 0, 0, targetWidth, targetHeight);\n\n    blob = await new Promise((resolve) =>\n      canvas.toBlob(resolve, \"image/png\")\n    );\n\n    if (!blob) {\n      throw new Error(\"Failed to encode resized image.\");\n    }\n\n    if (blob.size <= maxBytes) {\n      fits = true;\n      break;\n    }\n\n    currentScale *= STEP;\n    attempts += 1;\n  }\n\n  if (!blob) {\n    throw new Error(\"Failed to process image.\");\n  }\n\n  return { blob, resized: true, fits };\n}\n\nexport async function ensureImageWithinLimit(file, maxBytes) {\n  if (file.size <= maxBytes) {\n    const base64 = await blobToBase64(file);\n    return {\n      base64,\n      resized: false,\n      originalSize: file.size,\n      finalSize: file.size,\n    };\n  }\n\n  const image = await loadImageFromBlob(file);\n  const width = image.naturalWidth || image.width;\n  const height = image.naturalHeight || image.height;\n  if (!width || !height) {\n    throw new Error(\"Unable to read image dimensions.\");\n  }\n\n  const { blob, fits } = await resizeImageToLimit(image, file, maxBytes);\n\n  if (!fits || blob.size > maxBytes) {\n    throw new Error(\n      `Image is too large to upload. Please use an image smaller than ${formatByteSize(\n        maxBytes\n      )}.`\n    );\n  }\n\n  const base64 = await blobToBase64(blob);\n  return {\n    base64,\n    resized: true,\n    originalSize: file.size,\n    finalSize: blob.size,\n  };\n}\n\nexport function formatPaddingValue(value) {\n  if (!Number.isFinite(value)) {\n    return \"0\";\n  }\n  const rounded = Math.round(value * 1000) / 1000;\n  const fixed = rounded.toFixed(3);\n  const trimmed = fixed.replace(/(\\.\\d*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n  return trimmed;\n}\n\nexport function normalizePadding(value) {\n  if (!Number.isFinite(value) || Number.isNaN(value) || value < 0) {\n    return 0;\n  }\n  const clamped = Math.max(0, value);\n  return Math.round(clamped * 1000) / 1000;\n}\n\nexport function resolveColor(value, fallback) {\n  const HEX_COLOR_RE = /^#([0-9a-f]{6})$/i;\n  const base = value ?? fallback;\n  if (HEX_COLOR_RE.test(base)) {\n    return base.toLowerCase();\n  }\n  if (HEX_COLOR_RE.test(fallback)) {\n    return fallback.toLowerCase();\n  }\n  return \"#000000\";\n}\n\nexport function normalizeColorInput(value) {\n  return value.trim().toLowerCase();\n}\n\nexport function midpoint(a, b) {\n  return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };\n}\n\nexport function isClose(a, b, epsilon = 0.5) {\n  return Math.abs(a.x - b.x) < epsilon && Math.abs(a.y - b.y) < epsilon;\n}\n\nexport function centroid(points) {\n  if (points.length === 0) {\n    return { x: 0, y: 0 };\n  }\n  let sumX = 0;\n  let sumY = 0;\n  for (const point of points) {\n    sumX += point.x;\n    sumY += point.y;\n  }\n  return { x: sumX / points.length, y: sumY / points.length };\n}\n\nexport function distanceToSegment(point, start, end) {\n  const vx = end.x - start.x;\n  const vy = end.y - start.y;\n  const wx = point.x - start.x;\n  const wy = point.y - start.y;\n  const lengthSquared = vx * vx + vy * vy;\n\n  if (lengthSquared === 0) {\n    return Math.hypot(point.x - start.x, point.y - start.y);\n  }\n\n  let t = (wx * vx + wy * vy) / lengthSquared;\n  if (t < 0) {\n    t = 0;\n  } else if (t > 1) {\n    t = 1;\n  }\n\n  const projectionX = start.x + t * vx;\n  const projectionY = start.y + t * vy;\n  return Math.hypot(point.x - projectionX, point.y - projectionY);\n}\n\nexport function normalizeLabelLines(label) {\n  return label\n    .split(\"\\n\")\n    .map((line) => (line.length === 0 ? \"\\u00A0\" : line));\n}\n\nexport function measureLabelBox(lines) {\n  const EDGE_LABEL_MIN_WIDTH = 36;\n  const EDGE_LABEL_HORIZONTAL_PADDING = 16;\n  const EDGE_LABEL_MIN_HEIGHT = 28;\n  const EDGE_LABEL_LINE_HEIGHT = 16;\n  const EDGE_LABEL_VERTICAL_PADDING = 12;\n\n  let maxChars = 0;\n  for (const line of lines) {\n    maxChars = Math.max(maxChars, line.length);\n  }\n\n  const width = Math.max(\n    EDGE_LABEL_MIN_WIDTH,\n    7.4 * maxChars + EDGE_LABEL_HORIZONTAL_PADDING\n  );\n  const height = Math.max(\n    EDGE_LABEL_MIN_HEIGHT,\n    EDGE_LABEL_LINE_HEIGHT * lines.length + EDGE_LABEL_VERTICAL_PADDING\n  );\n\n  return { width, height };\n}\n\nexport function snapToGrid(value, gridSize = 10) {\n  if (gridSize <= 0) {\n    return value;\n  }\n  return Math.round(value / gridSize) * gridSize;\n}\n\nexport function svgSafeId(prefix, id) {\n  return `${prefix}${id.replace(/[^a-zA-Z0-9_:-]/g, \"_\")}`;\n}\n\nexport function polygonPoints(points) {\n  return points.map(([x, y]) => `${x.toFixed(1)},${y.toFixed(1)}`).join(\" \");\n}\n\n","// VSCode API adapter - converts fetch API calls to VSCode message passing\n\n//  VSCode webview \n// acquireVsCodeApi()  window.vscode\nlet vscode = null;\nlet isVSCodeWebview = false;\n\nif (typeof window !== 'undefined' && window.vscode) {\n  //  vscode\n  vscode = window.vscode;\n  isVSCodeWebview = true;\n} else if (typeof acquireVsCodeApi !== 'undefined') {\n  //  VS Code API\n  try {\n    vscode = acquireVsCodeApi();\n    isVSCodeWebview = !!vscode;\n    //  window \n    if (typeof window !== 'undefined') {\n      window.vscode = vscode;\n    }\n  } catch (e) {\n    //  window.vscode\n    if (typeof window !== 'undefined' && window.vscode) {\n      vscode = window.vscode;\n      isVSCodeWebview = true;\n    } else {\n      console.warn('[vscodeApi] Failed to acquire VS Code API:', e);\n    }\n  }\n}\n\n//  ID \nlet messageIdCounter = 0;\nfunction generateMessageId() {\n  return `msg_${Date.now()}_${++messageIdCounter}`;\n}\n\n//  Promise \nconst pendingMessages = new Map();\n\n// \nif (isVSCodeWebview) {\n  window.addEventListener('message', (event) => {\n    const data = event.data;\n    \n    //  API  messageId -\n    if (data.messageId && pendingMessages.has(data.messageId)) {\n      const { resolve, reject } = pendingMessages.get(data.messageId);\n      pendingMessages.delete(data.messageId);\n      \n      if (data.error) {\n        const error = new Error(data.error);\n        error.status = data.status || 500;\n        error.statusText = data.statusText || 'Internal Server Error';\n        reject(error);\n      } else {\n        resolve(data.result);\n      }\n      return;\n    }\n    \n    //  load\n    // load  app.js \n    //  window.onDiagramLoad \n    if ((data.type === 'load' || data.type === 'load-response') && data.diagram) {\n      //  window.pendingDiagram \n      if (typeof window !== 'undefined') {\n        window.pendingDiagram = data.diagram;\n      }\n      // \n      if (window.onDiagramLoad) {\n        window.onDiagramLoad(data.diagram);\n      }\n    }\n  });\n}\n\n// API  - \n// \n\nexport async function fetchDiagram() {\n  if (!isVSCodeWebview) {\n    throw new Error('Not in VSCode webview environment');\n  }\n  \n  return new Promise((resolve, reject) => {\n    const messageId = generateMessageId();\n    pendingMessages.set(messageId, { resolve, reject });\n    \n    vscode.postMessage({\n      type: 'api-fetchDiagram',\n      messageId,\n    });\n    \n    setTimeout(() => {\n      if (pendingMessages.has(messageId)) {\n        pendingMessages.delete(messageId);\n        reject(new Error('Request timeout'));\n      }\n    }, 30000);\n  });\n}\n\nexport async function saveDiagram(diagram) {\n  if (!isVSCodeWebview) {\n    throw new Error('Not in VSCode webview environment');\n  }\n  \n  return new Promise((resolve, reject) => {\n    const messageId = generateMessageId();\n    pendingMessages.set(messageId, { resolve, reject });\n    \n    vscode.postMessage({\n      type: 'api-saveDiagram',\n      messageId,\n      payload: { diagram },\n    });\n    \n    setTimeout(() => {\n      if (pendingMessages.has(messageId)) {\n        pendingMessages.delete(messageId);\n        reject(new Error('Request timeout'));\n      }\n    }, 30000);\n  });\n}\n\n//  saveDiagram\nexport async function updateLayout(update) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\nexport async function updateSource(source) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\nexport async function updateStyle(update) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\nexport async function deleteNode(nodeId) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\nexport async function deleteEdge(edgeId) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\nexport async function updateNodeImage(nodeId, payload) {\n  //  diagram  saveDiagram\n  //  app.js \n  return Promise.resolve();\n}\n\n//  VSCode API \nexport { vscode, isVSCodeWebview };\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nc = undefined;","// Main application entry point\n\nimport './styles.css';\nimport { StateManager } from '../lib/StateManager.js';\nimport { DiagramCanvas } from '../lib/DiagramCanvas.js';\nimport {\n  fetchDiagram,\n  saveDiagram,\n  isVSCodeWebview,\n  vscode,\n} from '../lib/vscodeApi.js';\nimport {\n  formatPaddingValue,\n  normalizePadding,\n  resolveColor,\n  normalizeColorInput,\n  formatByteSize,\n  ensureImageWithinLimit,\n} from '../lib/utils.js';\nimport {\n  DEFAULT_NODE_COLORS,\n  DEFAULT_EDGE_COLOR,\n  DEFAULT_NODE_TEXT,\n  MAX_IMAGE_FILE_BYTES,\n  LINE_STYLE_OPTIONS,\n  ARROW_DIRECTION_OPTIONS,\n} from '../lib/types.js';\n\n// Application class\nclass MermaidEditorApp {\n  constructor() {\n    this.stateManager = new StateManager();\n    this.diagramCanvas = null;\n    this.saveTimer = null;\n    this.lastSubmittedSource = null;\n    this.isSaving = false; // \n    \n    // DOM elements\n    this.elements = {\n      statusMessage: document.getElementById('status-message'),\n      errorMessage: document.getElementById('error-message'),\n      resetOverridesBtn: document.getElementById('reset-overrides-btn'),\n      deleteSelectedBtn: document.getElementById('delete-selected-btn'),\n      stylePanel: document.getElementById('style-panel'),\n      panelCaption: document.getElementById('panel-caption'),\n      stylePanelBody: document.getElementById('style-panel-body'),\n      diagramContainer: document.getElementById('diagram-container'),\n      sourcePanel: document.getElementById('source-panel'),\n      sourcePath: document.getElementById('source-path'),\n      sourceEditor: document.getElementById('source-editor'),\n      sourceStatus: document.getElementById('source-status'),\n      selectionLabel: document.getElementById('selection-label'),\n    };\n    \n    this.init();\n  }\n  \n  init() {\n    // Initialize diagram canvas\n    this.diagramCanvas = new DiagramCanvas(this.elements.diagramContainer, {\n      onNodeMove: (id, position) => this.handleNodeMove(id, position),\n      onEdgeMove: (id, points) => this.handleEdgeMove(id, points),\n      onLayoutUpdate: (update) => this.handleLayoutUpdate(update),\n      onSelectNode: (id) => this.handleSelectNode(id),\n      onSelectEdge: (id) => this.handleSelectEdge(id),\n      onDragStateChange: (dragging) => this.handleDragStateChange(dragging),\n      onDeleteNode: (id) => this.handleDeleteNode(id),\n      onDeleteEdge: (id) => this.handleDeleteEdge(id),\n    });\n    \n    // Subscribe to state changes\n    this.stateManager.subscribe((state) => this.onStateChange(state));\n    \n    // Setup event listeners\n    this.setupEventListeners();\n    \n    // Setup VSCode message listener (before loading diagram)\n    if (isVSCodeWebview) {\n      window.addEventListener('message', (event) => {\n        const data = event.data;\n        if (data.type === 'load' || data.type === 'load-response') {\n          // \n          if (this.isSaving) {\n            return;\n          }\n          if (data.diagram) {\n            this.handleDiagramLoad(data.diagram);\n          }\n        }\n      });\n      \n      // Check for pending diagram data (stored by inline script)\n      if (window.pendingDiagram) {\n        console.log('[MermaidEditor] Found pending diagram data, loading it');\n        this.handleDiagramLoad(window.pendingDiagram);\n        window.pendingDiagram = null; // Clear after use\n      } else {\n        // Load initial diagram if no pending data\n        this.loadDiagram();\n      }\n    } else {\n      // Not in VSCode, load diagram normally\n      this.loadDiagram();\n    }\n  }\n  \n  setupEventListeners() {\n    // Reset overrides button\n    this.elements.resetOverridesBtn.addEventListener('click', () => {\n      this.handleResetOverrides();\n    });\n    \n    // Delete selected button\n    this.elements.deleteSelectedBtn.addEventListener('click', () => {\n      this.handleDeleteSelection();\n    });\n    \n    // Source editor\n    this.elements.sourceEditor.addEventListener('input', (e) => {\n      this.handleSourceChange(e.target.value);\n    });\n    \n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => {\n      if ((e.ctrlKey || e.metaKey) && e.key === 's') {\n        e.preventDefault();\n        this.saveSource();\n      }\n    });\n  }\n  \n  handleDiagramLoad(diagram) {\n    // Unified method to handle diagram loading from any source\n    this.stateManager.setState({\n      diagram,\n      loading: false,\n      error: null,\n      source: diagram.source || '',\n      sourceDraft: diagram.source || '',\n    });\n    this.diagramCanvas.setDiagram(diagram);\n    if (diagram.source) {\n      this.elements.sourceEditor.value = diagram.source;\n    }\n    if (diagram.sourcePath) {\n      this.elements.sourcePath.textContent = diagram.sourcePath;\n    }\n  }\n  \n  async loadDiagram() {\n    try {\n      this.stateManager.setState({ loading: true, error: null });\n      const diagram = await fetchDiagram();\n      this.handleDiagramLoad(diagram);\n    } catch (error) {\n      this.stateManager.setState({\n        loading: false,\n        error: error.message,\n        diagram: null,\n      });\n    }\n  }\n  \n  async saveDiagram() {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) {\n      return;\n    }\n    \n    try {\n      this.isSaving = true; // \n      this.stateManager.setState({ saving: true, error: null });\n      await saveDiagram(diagram);\n      this.stateManager.setState({ saving: false });\n      \n      //  VSCode \n      setTimeout(() => {\n        this.isSaving = false;\n      }, 500);\n    } catch (error) {\n      this.isSaving = false;\n      this.stateManager.setState({ \n        saving: false,\n        error: error.message \n      });\n    }\n  }\n  \n  async handleNodeMove(id, position) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    //  diagram \n    const node = diagram.nodes.find(n => n.id === id);\n    if (node) {\n      if (position) {\n        node.overridePosition = position;\n        node.renderedPosition = position;\n      } else {\n        node.overridePosition = undefined;\n        node.renderedPosition = node.autoPosition;\n      }\n      await this.saveDiagram();\n    }\n  }\n  \n  async handleEdgeMove(id, points) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    //  diagram \n    const edge = diagram.edges.find(e => e.id === id);\n    if (edge) {\n      if (points && points.length > 0) {\n        edge.overridePoints = points;\n        edge.renderedPoints = points;\n      } else {\n        edge.overridePoints = undefined;\n        edge.renderedPoints = edge.autoPoints;\n      }\n      await this.saveDiagram();\n    }\n  }\n  \n  async handleLayoutUpdate(update) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    //  nodes\n    if (update.nodes) {\n      for (const [nodeId, position] of Object.entries(update.nodes)) {\n        const node = diagram.nodes.find(n => n.id === nodeId);\n        if (node) {\n          if (position) {\n            node.overridePosition = position;\n            node.renderedPosition = position;\n          } else {\n            node.overridePosition = undefined;\n            node.renderedPosition = node.autoPosition;\n          }\n        }\n      }\n    }\n    \n    //  edges\n    if (update.edges) {\n      for (const [edgeId, edgeUpdate] of Object.entries(update.edges)) {\n        const edge = diagram.edges.find(e => e.id === edgeId);\n        if (edge && edgeUpdate) {\n          if (edgeUpdate.points) {\n            edge.overridePoints = edgeUpdate.points;\n            edge.renderedPoints = edgeUpdate.points;\n          } else if (edgeUpdate.points === null) {\n            edge.overridePoints = undefined;\n            edge.renderedPoints = edge.autoPoints;\n          }\n        }\n      }\n    }\n    \n    await this.saveDiagram();\n  }\n  \n  async handleDeleteNode(id) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    //  diagram \n    const newDiagram = {\n      ...diagram,\n      nodes: diagram.nodes.filter(n => n.id !== id),\n      edges: diagram.edges.filter(e => e.from !== id && e.to !== id),\n    };\n    \n    // \n    if (this.stateManager.selectedNodeId === id) {\n      this.stateManager.setState({ selectedNodeId: null });\n    }\n    \n    //  stateManager  diagram \n    this.stateManager.setState({ diagram: newDiagram });\n    \n    //  canvas \n    this.diagramCanvas.setDiagram(newDiagram);\n    \n    // \n    await this.saveDiagram();\n  }\n  \n  async handleDeleteEdge(id) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    //  diagram \n    const newDiagram = {\n      ...diagram,\n      edges: diagram.edges.filter(e => e.id !== id),\n    };\n    \n    // \n    if (this.stateManager.selectedEdgeId === id) {\n      this.stateManager.setState({ selectedEdgeId: null });\n    }\n    \n    //  stateManager  diagram \n    this.stateManager.setState({ diagram: newDiagram });\n    \n    //  canvas \n    this.diagramCanvas.setDiagram(newDiagram);\n    \n    // \n    await this.saveDiagram();\n  }\n  \n  handleSelectNode(id) {\n    this.stateManager.setState({ selectedNodeId: id });\n    if (id) {\n      this.stateManager.setState({ selectedEdgeId: null });\n    }\n    this.updateStylePanel();\n  }\n  \n  handleSelectEdge(id) {\n    this.stateManager.setState({ selectedEdgeId: id });\n    if (id) {\n      this.stateManager.setState({ selectedNodeId: null });\n    }\n    this.updateStylePanel();\n  }\n  \n  handleDragStateChange(dragging) {\n    this.stateManager.setState({ dragging });\n  }\n  \n  handleDeleteSelection() {\n    if (this.stateManager.selectedNodeId) {\n      this.handleDeleteNode(this.stateManager.selectedNodeId);\n    } else if (this.stateManager.selectedEdgeId) {\n      this.handleDeleteEdge(this.stateManager.selectedEdgeId);\n    }\n  }\n  \n  async handleResetOverrides() {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) {\n      return;\n    }\n    \n    const nodesUpdate = {};\n    const edgesUpdate = {};\n    \n    for (const node of diagram.nodes) {\n      if (node.overridePosition) {\n        nodesUpdate[node.id] = null;\n      }\n    }\n    \n    for (const edge of diagram.edges) {\n      if (edge.overridePoints && edge.overridePoints.length > 0) {\n        edgesUpdate[edge.id] = { points: null };\n      }\n    }\n    \n    if (Object.keys(nodesUpdate).length === 0 && Object.keys(edgesUpdate).length === 0) {\n      return;\n    }\n    \n    await this.handleLayoutUpdate({ nodes: nodesUpdate, edges: edgesUpdate });\n  }\n  \n  async handleAddEdgeJoint() {\n    const selectedEdge = this.stateManager.getSelectedEdge();\n    if (!selectedEdge) {\n      return;\n    }\n    \n    const diagram = this.stateManager.diagram;\n    if (!diagram) {\n      return;\n    }\n    \n    const edge = diagram.edges.find(e => e.id === selectedEdge.id);\n    if (!edge) {\n      return;\n    }\n    \n    const route = edge.renderedPoints;\n    if (route.length < 2) {\n      return;\n    }\n    \n    // \n    let bestSegment = 0;\n    let bestLength = -Infinity;\n    for (let index = 0; index < route.length - 1; index++) {\n      const start = route[index];\n      const end = route[index + 1];\n      const length = Math.hypot(end.x - start.x, end.y - start.y);\n      if (length > bestLength) {\n        bestLength = length;\n        bestSegment = index;\n      }\n    }\n    \n    const start = route[bestSegment];\n    const end = route[bestSegment + 1];\n    const newPoint = {\n      x: (start.x + end.x) / 2,\n      y: (start.y + end.y) / 2,\n    };\n    \n    const currentOverrides = edge.overridePoints\n      ? edge.overridePoints.map(point => ({ ...point }))\n      : [];\n    \n    // \n    const alreadyPresent = currentOverrides.some(point => {\n      const dx = point.x - newPoint.x;\n      const dy = point.y - newPoint.y;\n      return Math.hypot(dx, dy) < 0.25;\n    });\n    if (alreadyPresent) {\n      return;\n    }\n    \n    const insertIndex = Math.min(bestSegment, currentOverrides.length);\n    currentOverrides.splice(insertIndex, 0, newPoint);\n    \n    edge.overridePoints = currentOverrides;\n    edge.renderedPoints = currentOverrides;\n    \n    await this.saveDiagram();\n    this.diagramCanvas.setDiagram(diagram);\n  }\n  \n  handleSourceChange(value) {\n    this.stateManager.setState({\n      sourceDraft: value,\n      sourceError: null,\n    });\n    this.lastSubmittedSource = null;\n    \n    // Auto-save with debounce\n    if (this.saveTimer) {\n      clearTimeout(this.saveTimer);\n    }\n    \n    this.saveTimer = setTimeout(() => {\n      this.saveSource();\n    }, 700);\n  }\n  \n  async saveSource() {\n    const sourceDraft = this.stateManager.sourceDraft;\n    const source = this.stateManager.source;\n    \n    if (sourceDraft === source) {\n      this.stateManager.setState({ sourceSaving: false, sourceError: null });\n      this.lastSubmittedSource = sourceDraft;\n      return;\n    }\n    \n    if (this.lastSubmittedSource === sourceDraft) {\n      return;\n    }\n    \n    try {\n      this.stateManager.setState({ sourceSaving: true });\n      \n      //  diagram  source\n      const diagram = this.stateManager.diagram;\n      if (diagram) {\n        diagram.source = sourceDraft;\n        await this.saveDiagram();\n      }\n      \n      this.stateManager.setState({\n        source: sourceDraft,\n        sourceSaving: false,\n        sourceError: null,\n      });\n      this.lastSubmittedSource = sourceDraft;\n    } catch (error) {\n      this.stateManager.setState({\n        sourceSaving: false,\n        sourceError: error.message,\n        error: error.message,\n      });\n    }\n  }\n  \n  updateStylePanel() {\n    const state = this.stateManager.getState();\n    const selectedNode = state.selectedNodeId ? this.stateManager.getSelectedNode() : null;\n    const selectedEdge = state.selectedEdgeId ? this.stateManager.getSelectedEdge() : null;\n    \n    // Update caption\n    if (selectedNode) {\n      this.elements.panelCaption.textContent = `: ${selectedNode.label || selectedNode.id}`;\n    } else if (selectedEdge) {\n      this.elements.panelCaption.textContent = `: ${selectedEdge.label || `${selectedEdge.from}${selectedEdge.to}`}`;\n    } else {\n      this.elements.panelCaption.textContent = '';\n      this.elements.panelCaption.className = 'panel-caption muted';\n    }\n    \n    // Clear existing controls\n    this.elements.stylePanelBody.innerHTML = '';\n    \n    if (selectedNode) {\n      this.renderNodeStyleControls(selectedNode, state);\n    } else if (selectedEdge) {\n      this.renderEdgeStyleControls(selectedEdge, state);\n    }\n  }\n  \n  renderNodeStyleControls(node, state) {\n    const section = document.createElement('section');\n    section.className = 'style-section';\n    \n    const header = document.createElement('header');\n    header.className = 'section-heading';\n    header.innerHTML = `\n      <h3></h3>\n      <span class=\"section-caption\">${node.label || node.id}</span>\n    `;\n    \n    const controls = document.createElement('div');\n    controls.className = 'style-controls';\n    controls.setAttribute('aria-disabled', state.saving || !node);\n    \n    // Fill color\n    if (!node.image) {\n      const fillControl = this.createColorControl('', 'node-fill', node.fillColor, DEFAULT_NODE_COLORS[node.shape], (value) => {\n        this.handleNodeFillChange(node.id, value);\n      });\n      controls.appendChild(fillControl);\n    }\n    \n    // Stroke color\n    const strokeControl = this.createColorControl('', 'node-stroke', node.strokeColor, DEFAULT_EDGE_COLOR, (value) => {\n      this.handleNodeStrokeChange(node.id, value);\n    });\n    controls.appendChild(strokeControl);\n    \n    // Text color\n    const textControl = this.createColorControl('', 'node-text', node.textColor, DEFAULT_NODE_TEXT, (value) => {\n      this.handleNodeTextColorChange(node.id, value);\n    });\n    controls.appendChild(textControl);\n    \n    // Image controls (if node has image)\n    if (node.image) {\n      const imageControl = this.createImageControl(node, state);\n      controls.appendChild(imageControl);\n      \n      // Title background color\n      const labelFillControl = this.createColorControl(\n        '',\n        'node-label-fill',\n        node.labelFillColor,\n        node.fillColor ?? DEFAULT_NODE_COLORS[node.shape],\n        (value) => {\n          this.handleNodeLabelFillChange(node.id, value);\n        }\n      );\n      controls.appendChild(labelFillControl);\n      \n      // Image background color\n      const imageFillControl = this.createColorControl(\n        '',\n        'node-image-fill',\n        node.imageFillColor,\n        '#ffffff',\n        (value) => {\n          this.handleNodeImageFillChange(node.id, value);\n        }\n      );\n      controls.appendChild(imageFillControl);\n    }\n    \n    // Reset button\n    const resetBtn = document.createElement('button');\n    resetBtn.type = 'button';\n    resetBtn.className = 'style-reset';\n    resetBtn.textContent = '';\n    resetBtn.disabled = state.saving || !node;\n    resetBtn.addEventListener('click', () => {\n      this.handleNodeStyleReset(node.id);\n    });\n    \n    section.appendChild(header);\n    section.appendChild(controls);\n    section.appendChild(resetBtn);\n    this.elements.stylePanelBody.appendChild(section);\n  }\n  \n  renderEdgeStyleControls(edge, state) {\n    const section = document.createElement('section');\n    section.className = 'style-section';\n    \n    const header = document.createElement('header');\n    header.className = 'section-heading';\n    header.innerHTML = `\n      <h3></h3>\n      <span class=\"section-caption\">${edge.label || `${edge.from}${edge.to}`}</span>\n    `;\n    \n    const controls = document.createElement('div');\n    controls.className = 'style-controls';\n    controls.setAttribute('aria-disabled', state.saving || !edge);\n    \n    // Color\n    const colorControl = this.createColorControl('', 'edge-color', edge.color, DEFAULT_EDGE_COLOR, (value) => {\n      this.handleEdgeColorChange(edge.id, value);\n    });\n    controls.appendChild(colorControl);\n    \n    // Line style\n    const lineControl = this.createSelectControl('', 'edge-line', LINE_STYLE_OPTIONS, edge.kind || 'solid', (value) => {\n      this.handleEdgeLineStyleChange(edge.id, value);\n    });\n    controls.appendChild(lineControl);\n    \n    // Arrow direction\n    const arrowControl = this.createSelectControl('', 'edge-arrow', ARROW_DIRECTION_OPTIONS, edge.arrowDirection || 'forward', (value) => {\n      this.handleEdgeArrowChange(edge.id, value);\n    });\n    controls.appendChild(arrowControl);\n    \n    // Add control point button\n    const addJointBtn = document.createElement('button');\n    addJointBtn.type = 'button';\n    addJointBtn.className = 'style-reset';\n    addJointBtn.textContent = '';\n    addJointBtn.disabled = state.saving || !edge;\n    addJointBtn.addEventListener('click', () => {\n      this.handleAddEdgeJoint();\n    });\n    \n    // Reset button\n    const resetBtn = document.createElement('button');\n    resetBtn.type = 'button';\n    resetBtn.className = 'style-reset';\n    resetBtn.textContent = '';\n    resetBtn.disabled = state.saving || !edge;\n    resetBtn.addEventListener('click', () => {\n      this.handleEdgeStyleReset(edge.id);\n    });\n    \n    section.appendChild(header);\n    section.appendChild(controls);\n    section.appendChild(addJointBtn);\n    section.appendChild(resetBtn);\n    this.elements.stylePanelBody.appendChild(section);\n  }\n  \n  createColorControl(label, id, value, fallback, onChange) {\n    const control = document.createElement('div');\n    control.className = 'style-control';\n    \n    const labelEl = document.createElement('span');\n    labelEl.textContent = label;\n    \n    const input = document.createElement('input');\n    input.type = 'color';\n    input.id = id;\n    input.value = resolveColor(value, fallback);\n    input.addEventListener('change', (e) => {\n      onChange(e.target.value);\n    });\n    \n    control.appendChild(labelEl);\n    control.appendChild(input);\n    return control;\n  }\n  \n  createSelectControl(label, id, options, value, onChange) {\n    const control = document.createElement('div');\n    control.className = 'style-control';\n    \n    const labelEl = document.createElement('span');\n    labelEl.textContent = label;\n    \n    const select = document.createElement('select');\n    select.id = id;\n    options.forEach(option => {\n      const optionEl = document.createElement('option');\n      optionEl.value = option.value;\n      optionEl.textContent = option.label;\n      if (option.value === value) {\n        optionEl.selected = true;\n      }\n      select.appendChild(optionEl);\n    });\n    select.addEventListener('change', (e) => {\n      onChange(e.target.value);\n    });\n    \n    control.appendChild(labelEl);\n    control.appendChild(select);\n    return control;\n  }\n  \n  createImageControl(node, state) {\n    const control = document.createElement('div');\n    control.className = 'style-control image-control';\n    \n    const label = document.createElement('span');\n    label.textContent = '';\n    \n    const actions = document.createElement('div');\n    actions.className = 'image-control-actions';\n    \n    const uploadBtn = document.createElement('button');\n    uploadBtn.type = 'button';\n    uploadBtn.textContent = node.image ? ' PNG' : ' PNG';\n    uploadBtn.disabled = state.saving;\n    uploadBtn.addEventListener('click', () => {\n      const input = document.createElement('input');\n      input.type = 'file';\n      input.accept = 'image/png';\n      input.addEventListener('change', (e) => {\n        this.handleNodeImageFileChange(node.id, e.target.files[0]);\n      });\n      input.click();\n    });\n    \n    const removeBtn = document.createElement('button');\n    removeBtn.type = 'button';\n    removeBtn.textContent = '';\n    removeBtn.disabled = state.saving || !node.image;\n    removeBtn.addEventListener('click', () => {\n      this.handleNodeImageRemove(node.id);\n    });\n    \n    actions.appendChild(uploadBtn);\n    actions.appendChild(removeBtn);\n    \n    const meta = document.createElement('span');\n    meta.className = node.image ? 'image-control-meta' : 'image-control-meta muted';\n    meta.textContent = node.image\n      ? `${node.image.width}x${node.image.height}px ( ${formatPaddingValue(node.image.padding)}px)`\n      : '';\n    \n    control.appendChild(label);\n    control.appendChild(actions);\n    control.appendChild(meta);\n    \n    // Add padding input if node has image\n    if (node.image) {\n      const paddingControl = document.createElement('div');\n      paddingControl.className = 'style-control';\n      \n      const paddingLabel = document.createElement('span');\n      paddingLabel.textContent = ' (px)';\n      \n      const paddingInput = document.createElement('input');\n      paddingInput.type = 'number';\n      paddingInput.min = '0';\n      paddingInput.step = '1';\n      paddingInput.value = formatPaddingValue(node.image.padding);\n      paddingInput.disabled = state.saving || !node.image;\n      \n      let paddingValue = formatPaddingValue(node.image.padding);\n      let commitTimer = null;\n      \n      paddingInput.addEventListener('input', (e) => {\n        paddingValue = e.target.value;\n        if (commitTimer) {\n          clearTimeout(commitTimer);\n        }\n      });\n      \n      const commitPadding = async () => {\n        const parsed = parseFloat(paddingValue);\n        if (!isFinite(parsed)) {\n          paddingInput.value = formatPaddingValue(node.image.padding);\n          return;\n        }\n        \n        const normalized = normalizePadding(Math.max(0, parsed));\n        const current = normalizePadding(node.image.padding);\n        const PADDING_EPSILON = 0.001;\n        \n        if (Math.abs(normalized - current) < PADDING_EPSILON) {\n          paddingInput.value = formatPaddingValue(current);\n          return;\n        }\n        \n        try {\n          this.stateManager.setState({ saving: true });\n          const diagram = this.stateManager.diagram;\n          if (diagram) {\n            const nodeToUpdate = diagram.nodes.find(n => n.id === node.id);\n            if (nodeToUpdate && nodeToUpdate.image) {\n              nodeToUpdate.image.padding = normalized;\n              await this.saveDiagram();\n              this.diagramCanvas.setDiagram(diagram);\n            }\n          }\n        } catch (error) {\n          this.stateManager.setState({ error: error.message });\n          paddingInput.value = formatPaddingValue(current);\n        } finally {\n          this.stateManager.setState({ saving: false });\n        }\n      };\n      \n      paddingInput.addEventListener('blur', () => {\n        commitPadding();\n      });\n      \n      paddingInput.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          e.preventDefault();\n          commitPadding();\n        } else if (e.key === 'Escape') {\n          e.preventDefault();\n          paddingInput.value = formatPaddingValue(node.image.padding);\n          paddingInput.blur();\n        }\n      });\n      \n      paddingControl.appendChild(paddingLabel);\n      paddingControl.appendChild(paddingInput);\n      control.appendChild(paddingControl);\n    }\n    \n    return control;\n  }\n  \n  async handleNodeFillChange(nodeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: { fill: normalized } },\n    });\n  }\n  \n  async handleNodeStrokeChange(nodeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: { stroke: normalized } },\n    });\n  }\n  \n  async handleNodeTextColorChange(nodeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: { text: normalized } },\n    });\n  }\n  \n  async handleNodeLabelFillChange(nodeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: { labelFill: normalized } },\n    });\n  }\n  \n  async handleNodeImageFillChange(nodeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: { imageFill: normalized } },\n    });\n  }\n  \n  async handleEdgeColorChange(edgeId, value) {\n    const normalized = normalizeColorInput(value);\n    await this.submitStyleUpdate({\n      edgeStyles: { [edgeId]: { color: normalized } },\n    });\n  }\n  \n  async handleEdgeLineStyleChange(edgeId, value) {\n    await this.submitStyleUpdate({\n      edgeStyles: { [edgeId]: { line: value } },\n    });\n  }\n  \n  async handleEdgeArrowChange(edgeId, value) {\n    await this.submitStyleUpdate({\n      edgeStyles: { [edgeId]: { arrow: value } },\n    });\n  }\n  \n  async handleNodeStyleReset(nodeId) {\n    await this.submitStyleUpdate({\n      nodeStyles: { [nodeId]: null },\n    });\n  }\n  \n  async handleEdgeStyleReset(edgeId) {\n    await this.submitStyleUpdate({\n      edgeStyles: { [edgeId]: null },\n    });\n  }\n  \n  async submitStyleUpdate(update) {\n    const hasNodeStyles = update.nodeStyles && Object.keys(update.nodeStyles).length > 0;\n    const hasEdgeStyles = update.edgeStyles && Object.keys(update.edgeStyles).length > 0;\n    if (!hasNodeStyles && !hasEdgeStyles) {\n      return;\n    }\n    \n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    try {\n      this.stateManager.setState({ saving: true, error: null });\n      \n      // \n      if (update.nodeStyles) {\n        for (const [nodeId, styleUpdate] of Object.entries(update.nodeStyles)) {\n          const node = diagram.nodes.find(n => n.id === nodeId);\n          if (!node) continue;\n          \n          if (styleUpdate === null) {\n            // \n            node.fillColor = undefined;\n            node.strokeColor = undefined;\n            node.textColor = undefined;\n            node.labelFillColor = undefined;\n            node.imageFillColor = undefined;\n          } else {\n            if (styleUpdate.fill !== undefined) node.fillColor = styleUpdate.fill;\n            if (styleUpdate.stroke !== undefined) node.strokeColor = styleUpdate.stroke;\n            if (styleUpdate.text !== undefined) node.textColor = styleUpdate.text;\n            if (styleUpdate.labelFill !== undefined) node.labelFillColor = styleUpdate.labelFill;\n            if (styleUpdate.imageFill !== undefined) node.imageFillColor = styleUpdate.imageFill;\n          }\n        }\n      }\n      \n      // \n      if (update.edgeStyles) {\n        for (const [edgeId, styleUpdate] of Object.entries(update.edgeStyles)) {\n          const edge = diagram.edges.find(e => e.id === edgeId);\n          if (!edge) continue;\n          \n          if (styleUpdate === null) {\n            // \n            edge.color = undefined;\n            edge.kind = 'solid';\n            edge.arrowDirection = 'forward';\n          } else {\n            if (styleUpdate.color !== undefined) edge.color = styleUpdate.color;\n            if (styleUpdate.line !== undefined) edge.kind = styleUpdate.line;\n            if (styleUpdate.arrow !== undefined) edge.arrowDirection = styleUpdate.arrow;\n          }\n        }\n      }\n      \n      //  stateManager  diagram \n      this.stateManager.setState({ diagram });\n      \n      //  canvas \n      this.diagramCanvas.setDiagram(diagram);\n      \n      await this.saveDiagram();\n    } catch (error) {\n      this.stateManager.setState({ error: error.message });\n    } finally {\n      this.stateManager.setState({ saving: false });\n    }\n  }\n  \n  async handleNodeImageFileChange(nodeId, file) {\n    if (!file) {\n      return;\n    }\n    \n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    const declaredType = file.type ? file.type.toLowerCase() : '';\n    const effectiveType = declaredType || (file.name.toLowerCase().endsWith('.png') ? 'image/png' : '');\n    \n    if (effectiveType !== 'image/png') {\n      this.stateManager.setState({ error: 'Only PNG images are supported for nodes.' });\n      return;\n    }\n    \n    try {\n      const preparedImage = await ensureImageWithinLimit(file, MAX_IMAGE_FILE_BYTES);\n      \n      if (preparedImage.resized) {\n        alert(\n          `The selected image was ${formatByteSize(preparedImage.originalSize)}. We resized it to ${formatByteSize(preparedImage.finalSize)} to stay under the ${formatByteSize(MAX_IMAGE_FILE_BYTES)} limit.`\n        );\n      }\n      \n      this.stateManager.setState({ saving: true, error: null });\n      \n      //  - \n      const node = diagram.nodes.find(n => n.id === nodeId);\n      if (node) {\n        // base64\n        const img = new Image();\n        await new Promise((resolve, reject) => {\n          img.onload = () => resolve();\n          img.onerror = reject;\n          img.src = `data:${effectiveType};base64,${preparedImage.base64}`;\n        });\n        \n        const existingPadding = node.image?.padding ?? 0;\n        node.image = {\n          mimeType: effectiveType,\n          data: preparedImage.base64,\n          width: img.naturalWidth || img.width || 100,\n          height: img.naturalHeight || img.height || 100,\n          padding: existingPadding,\n        };\n      }\n      \n      await this.saveDiagram();\n      this.diagramCanvas.setDiagram(diagram);\n    } catch (error) {\n      this.stateManager.setState({ error: error.message });\n      alert(`${error.message} Maximum allowed size is ${formatByteSize(MAX_IMAGE_FILE_BYTES)}.`);\n    } finally {\n      this.stateManager.setState({ saving: false });\n    }\n  }\n  \n  async handleNodeImageRemove(nodeId) {\n    const diagram = this.stateManager.diagram;\n    if (!diagram) return;\n    \n    try {\n      this.stateManager.setState({ saving: true, error: null });\n      \n      const node = diagram.nodes.find(n => n.id === nodeId);\n      if (node) {\n        node.image = undefined;\n      }\n      \n      await this.saveDiagram();\n      this.diagramCanvas.setDiagram(diagram);\n    } catch (error) {\n      this.stateManager.setState({ error: error.message });\n    } finally {\n      this.stateManager.setState({ saving: false });\n    }\n  }\n  \n  onStateChange(state) {\n    // Update status message\n    let statusMessage = '';\n    if (state.loading) {\n      statusMessage = '...';\n    } else if (state.saving) {\n      statusMessage = '...';\n    } else if (state.sourceSaving) {\n      statusMessage = '...';\n    } else if (state.error) {\n      statusMessage = `: ${state.error}`;\n    } else if (state.diagram) {\n      statusMessage = ` ${state.diagram.sourcePath || ''}`;\n    }\n    this.elements.statusMessage.textContent = statusMessage;\n    \n    // Update error message\n    if (state.error) {\n      this.elements.errorMessage.textContent = state.error;\n      this.elements.errorMessage.style.display = 'block';\n    } else {\n      this.elements.errorMessage.style.display = 'none';\n    }\n    \n    // Update buttons\n    this.elements.resetOverridesBtn.disabled = !this.stateManager.hasOverrides() || state.saving || state.sourceSaving;\n    const hasSelection = state.selectedNodeId !== null || state.selectedEdgeId !== null;\n    this.elements.deleteSelectedBtn.disabled = !hasSelection || state.saving || state.sourceSaving;\n    \n    // Update source status\n    let sourceStatusText = '';\n    let sourceStatusClass = 'synced';\n    if (state.sourceError) {\n      sourceStatusText = state.sourceError;\n      sourceStatusClass = 'error';\n    } else if (state.sourceSaving) {\n      sourceStatusText = '';\n      sourceStatusClass = 'saving';\n    } else if (state.sourceDraft !== state.source) {\n      sourceStatusText = '';\n      sourceStatusClass = 'pending';\n    }\n    this.elements.sourceStatus.textContent = sourceStatusText;\n    this.elements.sourceStatus.className = `source-status ${sourceStatusClass}`;\n    \n    // Update selection label\n    let selectionLabel = '';\n    if (state.selectedNodeId) {\n      selectionLabel = `: ${state.selectedNodeId}`;\n    } else if (state.selectedEdgeId) {\n      selectionLabel = `: ${state.selectedEdgeId}`;\n    }\n    this.elements.selectionLabel.textContent = selectionLabel;\n    \n    // Update style panel\n    this.updateStylePanel();\n    \n    // Update diagram canvas selection\n    if (this.diagramCanvas) {\n      this.diagramCanvas.setSelectedNode(state.selectedNodeId);\n      this.diagramCanvas.setSelectedEdge(state.selectedEdgeId);\n    }\n  }\n}\n\n// Initialize app when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    window.app = new MermaidEditorApp();\n  });\n} else {\n  window.app = new MermaidEditorApp();\n}\n\n"],"names":[],"ignoreList":[],"sourceRoot":""}